// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#include "ITMVisualisationEngine_CUDA.h"
#include "ITMVisualisationHelpers_CUDA.h"

#include <stdgpu/unordered_set.cuh>
#include <stdgpu/unordered_map.cuh>
#include <ITMLib/Objects/Scene/TSDF_CUDA.h>
#include <thrust/sequence.h>
#include <thrust/transform.h>
#include <ITMLib/Utils/ITMTimer.h>
#include <ITMLib/Engines/Reconstruction/Shared/ITMBlockTraversal.h>
#include <ORUtils/FileUtils.h>

namespace ITMLib
{

inline dim3 getGridSize(dim3 taskSize, dim3 blockSize)
{
	return dim3((taskSize.x + blockSize.x - 1) / blockSize.x, (taskSize.y + blockSize.y - 1) / blockSize.y,
	            (taskSize.z + blockSize.z - 1) / blockSize.z);
}

inline dim3 getGridSize(Vector2i taskSize, dim3 blockSize)
{ return getGridSize(dim3(taskSize.x, taskSize.y), blockSize); }

ITMVisualisationEngine_CUDA::ITMVisualisationEngine_CUDA(std::shared_ptr<const ITMLibSettings> settings)
	: ITMVisualisationEngine(settings)
{
	ORcudaSafeCall(cudaMalloc((void**) &renderingBlockList_device, sizeof(RenderingBlock) * MAX_RENDERING_BLOCKS));
	ORcudaSafeCall(cudaMalloc((void**) &noTotalBlocks_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**) &this->noTotalPoints_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**) &noVisibleEntries_device, sizeof(uint)));

	combinedTSDFWeights_device = nullptr;
	combinedTSDF_device = new stdgpu::unordered_map<Vector3s, Vector6f*>;

	if (CombineTSDFForRendering())
	{
		renderingTSDF = new TSDF_CUDA<ITMIndexXYZ, ITMVoxel>(settings->sceneParams.allocationSize / 4);
//	*combinedTSDF_device = stdgpu::unordered_map<Vector3s, Vector6f*>::createDeviceObject(100000);
	}
}

ITMVisualisationEngine_CUDA::~ITMVisualisationEngine_CUDA()
{
	ORcudaSafeCall(cudaFree(this->noTotalPoints_device));
	ORcudaSafeCall(cudaFree(noTotalBlocks_device));
	ORcudaSafeCall(cudaFree(renderingBlockList_device));
	ORcudaSafeCall(cudaFree(noVisibleEntries_device));

	delete renderingTSDF;

	if (combinedTSDF_device)
		stdgpu::unordered_map<Vector3s, Vector6f*>::destroyDeviceObject(*combinedTSDF_device);
	delete combinedTSDF_device;
	destroyDeviceArray(combinedTSDFWeights_device);
}

ITMRenderState_VH* ITMVisualisationEngine_CUDA::CreateRenderState(const Scene* scene, const Vector2i& imgSize) const
{
	return new ITMRenderState_VH(
		ITMVoxelBlockHash::noTotalEntries, imgSize, scene->sceneParams->viewFrustum_min,
		scene->sceneParams->viewFrustum_max, MEMORYDEVICE_CUDA
	);
}


#define ReadVoxelSDFDiscardZero(dst, blk, pos) voxel = &blk[VoxelIndicesToOffset(pos.x, pos.y, pos.z)]; if (voxel->w_depth == 0) return Vector3f(0, 0, 0); dst = voxel->sdf;
_CPU_AND_GPU_CODE_ inline Vector3f computeGradient(ITMVoxel* block, ITMVoxel** neighbors, const Vector3i& idx, float tau)
{
	if (not block)
		return Vector3f(0, 0, 0);

	if (idx.x == 0 and not neighbors[1])
		return Vector3f(0, 0, 0);
	if (idx.x == 7 and not neighbors[0])
		return Vector3f(0, 0, 0);
	if (idx.y == 0 and not neighbors[3])
		return Vector3f(0, 0, 0);
	if (idx.y == 7 and not neighbors[2])
		return Vector3f(0, 0, 0);
	if (idx.z == 0 and not neighbors[5])
		return Vector3f(0, 0, 0);
	if (idx.z == 7 and not neighbors[4])
		return Vector3f(0, 0, 0);

	bool found;
	ITMVoxel* voxel;
	Vector3f ret(0, 0, 0);
	float p1, p2;

	// gradient x
	if (idx.x == 7)
	{
		ReadVoxelSDFDiscardZero(p1, neighbors[static_cast<TSDFDirection_type>(TSDFDirection::X_POS)], Vector3i(0, idx.y, idx.z));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p1, block, Vector3i(idx.x + 1, idx.y, idx.z));
	}
	if (idx.x == 0)
	{
		ReadVoxelSDFDiscardZero(p2, neighbors[1], Vector3i(7, idx.y, idx.z));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p2, block, Vector3i(idx.x - 1, idx.y, idx.z));
	}
	ret.x = ITMVoxel::valueToFloat(p1 - p2);

	// gradient y
	if (idx.y == 7)
	{
		ReadVoxelSDFDiscardZero(p1, neighbors[2], Vector3i(idx.x, 0, idx.z));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p1, block, Vector3i(idx.x, idx.y + 1, idx.z));
	}
	if (idx.y == 0)
	{
		ReadVoxelSDFDiscardZero(p2, neighbors[3], Vector3i(idx.x, 7, idx.z));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p2, block, Vector3i(idx.x, idx.y - 1, idx.z));
	}
	ret.y = ITMVoxel::valueToFloat(p1 - p2);

	// gradient z
	if (idx.z == 7)
	{
		ReadVoxelSDFDiscardZero(p1, neighbors[4], Vector3i(idx.x, idx.y, 0));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p1, block, Vector3i(idx.x, idx.y, idx.z + 1));
	}
	if (idx.z == 0)
	{
		ReadVoxelSDFDiscardZero(p2, neighbors[5], Vector3i(idx.x, idx.y, 7));
	}
	else
	{
		ReadVoxelSDFDiscardZero(p2, block, Vector3i(idx.x, idx.y, idx.z - 1));
	}
	ret.z = ITMVoxel::valueToFloat(p1 - p2);

	if (ret == Vector3f(0, 0, 0))
		return Vector3f(0, 0, 0);

	if (tau > 0)
	{
		// Check each direction maximum 2 * truncationDistance / voxelSize + margin
		if (abs(ret.x) > 2.4 * tau or abs(ret.y) > 2.4 * tau or abs(ret.z) > 2.4 * tau)
			return Vector3f(0, 0, 0);
		// Check, if ret too unreliable (very close values in neighboring voxels). minimum expected length: (2 * tau)^2
		if (ORUtils::dot(ret, ret) < 2 * (tau * tau)) return Vector3f(0, 0, 0);
	}

	return ret.normalised();
}

/**
 * A faster version of combineDiretionalTSDFViewPoint that uses shared memory between threads to reduce tsdf lookups
 * @param renderingTSDF
 * @param tsdf
 * @param visibleBlocks
 * @param numVisibleBlocks
 * @param invM
 * @param voxelSize
 * @param mu
 * @param maxW
 */
__global__ void
combineDirectionalTSDFViewPoint2(stdgpu::unordered_map<ITMIndexXYZ, ITMVoxel*> renderingTSDF,
                                 const stdgpu::unordered_map<ITMIndex, ITMVoxel*> tsdf,
                                 const Vector3s* visibleBlocks, const stdgpu::index_t numVisibleBlocks,
                                 const Matrix4f invM, const float voxelSize, const float mu, const int maxW)
{
	stdgpu::index_t i = static_cast<stdgpu::index_t>(blockIdx.x);
	if (i >= numVisibleBlocks) return;

	int linearIdx = blockIdx.y * blockDim.x + threadIdx.x;

	const Vector3s& blockPos = visibleBlocks[i];

	__shared__ ITMVoxel* renderBlock;
	__shared__ ITMVoxel* blocks[N_DIRECTIONS];
	__shared__ ITMVoxel* neighborBlocks[6 * N_DIRECTIONS];
	if (linearIdx == 6)
	{
			auto it = renderingTSDF.find(blockPos);
			renderBlock = nullptr;
			if (it != renderingTSDF.end())
				renderBlock = it->second;
	}
	if (linearIdx >= 0 and linearIdx < 6)
	{
		ITMIndex index = ITMIndex(blockPos, TSDFDirection(linearIdx));

		auto it = tsdf.find(index);
		if (it == tsdf.end())
		{
			blocks[linearIdx] = nullptr;
		} else
		{
			blocks[linearIdx] = it->second;
		}
	}
	if (linearIdx >= 7 and linearIdx < 7 + 6 * N_DIRECTIONS)
	{
		int offset = linearIdx - 7;
		int directionIdx = offset / N_DIRECTIONS;
		int neighborIdx = offset % 6;

		Vector3s shift[6] =
			{
				Vector3s(1, 0, 0),
				Vector3s(-1, 0, 0),
				Vector3s(0, 1, 0),
				Vector3s(0, -1, 0),
				Vector3s(0, 0, 1),
				Vector3s(0, 0, -1)
			};
		ITMIndex index = ITMIndex(blockPos + shift[neighborIdx], TSDFDirection(directionIdx));
		auto it = tsdf.find(index);
		if (it == tsdf.end())
			neighborBlocks[directionIdx * 6 + neighborIdx] = nullptr;
		else
			neighborBlocks[directionIdx * 6 + neighborIdx] = it->second;
	}

	__syncthreads();

	if (not renderBlock)
		return;

	ITMVoxel& voxel = renderBlock[linearIdx];
	Vector3i voxelPosIdx = blockToVoxelPos(Vector3i(blockPos.x, blockPos.y, blockPos.z))
	                       + voxelOffsetToCoordinate(linearIdx);
	Vector3f voxelPos = voxelPosIdx.toFloat();
	Vector3f rayDirection = (voxelPos * voxelSize - (invM * Vector4f(0, 0, 0, 1)).toVector3()).normalised();

	Vector3f colorCombined(0, 0, 0);
	float sdfCombined = 0;
	float weightCombined = 0;
	float colorWeightCombined = 0;

	Vector3f colorCombinedNoGradient(0, 0, 0);
	Vector3f gradientCombined(0, 0, 0);
	float sdfCombinedNoGradient = 0;
	float weightCombinedNoGradient = 0;
	float colorWeightCombinedNoGradient = 0;

	Vector3f colorFreeSpace(0, 0, 0);
	Vector3f gradientFreeSpace(0, 0, 0);
	float freeSpaceWeight = 0;
	float freeSpaceSDF = 0;


	for (TSDFDirection_type directionIdx = 0; directionIdx < N_DIRECTIONS; directionIdx++)
	{
		ITMVoxel* block = blocks[directionIdx];
		if (not block)
			continue;

		float sdf = block[linearIdx].sdf;
		float w_depth = block[linearIdx].w_depth;

		bool found = false;

		Vector3f color;
		float color_w = 1;
		if (RENDER_DIRECTION_COLORS == 1)
			color = TSDFDirectionColor[directionIdx];
		else
			color = readFromSDF_color4u_uninterpolated(color_w, tsdf, voxelPos, maxW, TSDFDirection(directionIdx)).toVector3();

		Vector3f gradient = computeGradient(block, neighborBlocks + directionIdx * 6, voxelOffsetToCoordinate(linearIdx), voxelSize / mu);

		float weight =
			DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx)))
			* ORUtils::dot(gradient, -rayDirection)
			* w_depth;
		weight = MAX(weight, 0);

		float weightNoGradient = MAX(0,
		                             w_depth
		                             * ORUtils::dot(-rayDirection, TSDFDirectionVector[directionIdx])
//		                             * DirectionWeight(DirectionAngle(-rayDirection, TSDFDirection(directionIdx)))
		);
		weightCombinedNoGradient += weightNoGradient;
		sdfCombinedNoGradient += weightNoGradient * sdf;
		colorWeightCombinedNoGradient += weightNoGradient * color_w;
		colorCombinedNoGradient += weightNoGradient * color_w * color;

		sdfCombined += weight * sdf;
		weightCombined += weight;
		colorWeightCombined += weight * color_w;
		colorCombined += weight * color_w * color;
		gradientCombined += weight * gradient;
	}

	bool hasGradient = gradientCombined.x != 0 or gradientCombined.y != 0 or gradientCombined.z != 0;
	bool hasFreeSpaceGradient = gradientFreeSpace.x != 0 or gradientFreeSpace.y != 0 or gradientFreeSpace.z != 0;

	if (weightCombined > 0)
	{
		sdfCombined /= weightCombined;
		if (hasGradient) gradientCombined = gradientCombined.normalised();
	} else if (weightCombinedNoGradient > 0)
	{
		sdfCombined = sdfCombinedNoGradient / weightCombinedNoGradient;
		weightCombined = weightCombinedNoGradient;
		gradientCombined = Vector3f(0, 0, 0);
	} else
	{
		sdfCombined = 1;
		weightCombined = 0;
		gradientCombined = Vector3f(0, 0, 0);
	}

	if (colorWeightCombined > 0)
	{
		colorCombined /= colorWeightCombined;
	}
	else if (colorWeightCombinedNoGradient > 0)
	{
		colorCombined = colorCombinedNoGradient / colorWeightCombinedNoGradient;
		colorWeightCombined = colorWeightCombinedNoGradient;
	} else {
		colorCombined = Vector3f(0, 0, 0);
		colorWeightCombined = 0;
	}

	if (freeSpaceWeight > 0)
	{
		freeSpaceSDF /= freeSpaceWeight;
		colorFreeSpace /= freeSpaceWeight;
		if (hasFreeSpaceGradient)
			gradientFreeSpace = gradientFreeSpace.normalised();
	}

	if (freeSpaceWeight > 0
	    and ((hasGradient and hasFreeSpaceGradient
	          and dot(gradientFreeSpace, gradientCombined) <
	              0.707 // if same surface, use normal combination instead of free space (prevent dents in surface)
	          and dot(gradientFreeSpace, gradientCombined) > -0.707 // if opposite surface, don't carve
	         ) or (not hasGradient and not hasFreeSpaceGradient)))
	{
		voxel.sdf = ITMVoxel::floatToValue(freeSpaceSDF);
		voxel.w_depth = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
		voxel.clr = TO_UCHAR3(colorFreeSpace * 255.0f);
		voxel.w_color = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
	} else
	{
		voxel.sdf = ITMVoxel::floatToValue(sdfCombined);
		voxel.w_depth = ITMVoxel::floatToWeight(weightCombined, maxW);
		voxel.clr = TO_UCHAR3(colorCombined * 255.0f);
		voxel.w_color = ITMVoxel::floatToWeight(colorWeightCombined, maxW);
	}
}

__global__ void
combineDirectionalTSDFViewPoint(stdgpu::unordered_map<ITMIndexXYZ, ITMVoxel*> renderingTSDF,
                                const stdgpu::unordered_map<ITMIndex, ITMVoxel*> tsdf,
																const Vector3s* visibleBlocks, const stdgpu::index_t numVisibleBlocks,
                                const Matrix4f invM, const float voxelSize, const float mu, const int maxW)
{
	stdgpu::index_t i = static_cast<stdgpu::index_t>(blockIdx.x);
	if (i >= numVisibleBlocks) return;
	const Vector3s& blockPos = visibleBlocks[i];
	int linearIdx = blockIdx.y * blockDim.x + threadIdx.x;

	auto it = renderingTSDF.find(blockPos);
	if (it == renderingTSDF.end())
		return;

	ITMVoxel* block = it->second;

	ITMVoxel& voxel = block[linearIdx];
	Vector3i voxelPosIdx = blockToVoxelPos(Vector3i(blockPos.x, blockPos.y, blockPos.z))
	                       + voxelOffsetToCoordinate(linearIdx);
	Vector3f voxelPos = voxelPosIdx.toFloat();
	Vector3f rayDirection = (voxelPos * voxelSize - (invM * Vector4f(0, 0, 0, 1)).toVector3()).normalised();

	Vector3f colorCombined(0, 0, 0);
	float sdfCombined = 0;
	float weightCombined = 0;
	float colorWeightCombined = 0;

	Vector3f colorCombinedNoGradient(0, 0, 0);
	Vector3f gradientCombined(0, 0, 0);
	float sdfCombinedNoGradient = 0;
	float weightCombinedNoGradient = 0;
	float colorWeightCombinedNoGradient = 0;

	Vector3f colorFreeSpace(0, 0, 0);
	Vector3f gradientFreeSpace(0, 0, 0);
	float freeSpaceWeight = 0;
	float freeSpaceSDF = 0;

	for (TSDFDirection_type directionIdx = 0; directionIdx < N_DIRECTIONS; directionIdx++)
	{
		float confidence = 0;
		bool found = false;
		float sdf = readWithConfidenceFromSDF_float_uninterpolated(found, confidence, tsdf, voxelPos,
		                                                           maxW, TSDFDirection(directionIdx));
		if (not found)
			continue;

		Vector3f color;
		float color_w = 1;
		if (RENDER_DIRECTION_COLORS == 1)
			color = TSDFDirectionColor[directionIdx];
		else
			color = readFromSDF_color4u_uninterpolated(color_w, tsdf, voxelPos, maxW, TSDFDirection(directionIdx)).toVector3();
		Vector3f gradient = computeSingleNormalFromSDF(tsdf, voxelPos.toIntFloor(), TSDFDirection(directionIdx), voxelSize / mu);

		float weight =
			DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx)))
			* ORUtils::dot(gradient, -rayDirection)
			* confidence;
		weight = MAX(weight, 0);

//		if (voxelPosIdx.x == -71 and voxelPosIdx.y == -24 and voxelPosIdx.z == 258)
//			printf("[%i] (%f, %f, [%f, %f, %f], %f) [%f, %f, %f] (%.12f, %.12f, %.12f) -> %.12f\n", directionIdx, sdf, confidence,
//				color.x, color.y, color.z, color_w,
//				gradient.x, gradient.y, gradient.z,
//			  DirectionAngle(gradient, TSDFDirection(directionIdx)),
//				DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx))),
//				ORUtils::dot(gradient, -rayDirection), weight);

//		if (confidence > 0 and sdf > 0
//		    and ORUtils::length(gradient) > 0)
//		{ // free space
//
//			// Don't carve, if this is the "backside" of a face
//			BlockTraversal bt(voxelPos * voxelSize, -rayDirection, 2 * mu, voxelSize, true);
//			bool carve = true;
//			while (bt.HasNextBlock())
//			{
//				Vector3i vIdx = bt.GetNextBlock();
//
//				float sdf_ = readFromSDF_float_uninterpolated(found, tsdf, vIdx.toFloat(), TSDFDirection(directionIdx));
//				if (sdf_ < 0)
//				{
//					carve = false;
//					break;
//				}
//			}
//
//			if (carve)
//			{
////				float weightFS = weight;
//				float weightFS = confidence
//				                 //				                 * ORUtils::dot(-rayDirection, TSDFDirectionVector[directionIdx])
//
//				                 * MAX(0, ORUtils::dot(gradient, TSDFDirectionVector[directionIdx]))
////				                 * DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx)))
//				;
//
//				weightFS = MAX(weightFS, 0);
//
//				freeSpaceSDF += weightFS * sdf;
//				freeSpaceWeight += weightFS;
//				colorFreeSpace += weightFS * color;
//				gradientFreeSpace += weightFS * gradient;
//			}
//		}

		float weightNoGradient = MAX(0,
		                             confidence
		                             * ORUtils::dot(-rayDirection, TSDFDirectionVector[directionIdx])
//		                             * DirectionWeight(DirectionAngle(-rayDirection, TSDFDirection(directionIdx)))
		);
		weightCombinedNoGradient += weightNoGradient;
		sdfCombinedNoGradient += weightNoGradient * sdf;
		colorWeightCombinedNoGradient += weightNoGradient * color_w;
		colorCombinedNoGradient += weightNoGradient * color_w * color;

		sdfCombined += weight * sdf;
		weightCombined += weight;
		colorWeightCombined += weight * color_w;
		colorCombined += weight * color_w * color;
		gradientCombined += weight * gradient;
	}

	bool hasGradient = gradientCombined.x != 0 or gradientCombined.y != 0 or gradientCombined.z != 0;
	bool hasFreeSpaceGradient = gradientFreeSpace.x != 0 or gradientFreeSpace.y != 0 or gradientFreeSpace.z != 0;

	if (weightCombined > 0)
	{
		sdfCombined /= weightCombined;
		if (hasGradient) gradientCombined = gradientCombined.normalised();
	} else if (weightCombinedNoGradient > 0)
	{
		sdfCombined = sdfCombinedNoGradient / weightCombinedNoGradient;
		weightCombined = weightCombinedNoGradient;
		gradientCombined = Vector3f(0, 0, 0);
	} else
	{
		sdfCombined = 1;
		weightCombined = 0;
		gradientCombined = Vector3f(0, 0, 0);
	}

	if (colorWeightCombined > 0)
	{
		colorCombined /= colorWeightCombined;
	}
	else if (colorWeightCombinedNoGradient > 0)
	{
		colorCombined = colorCombinedNoGradient / colorWeightCombinedNoGradient;
		colorWeightCombined = colorWeightCombinedNoGradient;
	} else {
		colorCombined = Vector3f(0, 0, 0);
		colorWeightCombined = 0;
	}

	if (freeSpaceWeight > 0)
	{
		freeSpaceSDF /= freeSpaceWeight;
		colorFreeSpace /= freeSpaceWeight;
		if (hasFreeSpaceGradient)
			gradientFreeSpace = gradientFreeSpace.normalised();
	}

	if (freeSpaceWeight > 0
	    and ((hasGradient and hasFreeSpaceGradient
	          and dot(gradientFreeSpace, gradientCombined) <
	              0.707 // if same surface, use normal combination instead of free space (prevent dents in surface)
	          and dot(gradientFreeSpace, gradientCombined) > -0.707 // if opposite surface, don't carve
	         ) or (not hasGradient and not hasFreeSpaceGradient)))
	{
		voxel.sdf = ITMVoxel::floatToValue(freeSpaceSDF);
		voxel.w_depth = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
		voxel.clr = TO_UCHAR3(colorFreeSpace * 255.0f);
		voxel.w_color = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
	} else
	{
		voxel.sdf = ITMVoxel::floatToValue(sdfCombined);
		voxel.w_depth = ITMVoxel::floatToWeight(weightCombined, maxW);
		voxel.clr = TO_UCHAR3(colorCombined * 255.0f);
		voxel.w_color = ITMVoxel::floatToWeight(colorWeightCombined, maxW);
	}

//	if (voxelPosIdx.x == -71 and voxelPosIdx.y == -24 and voxelPosIdx.z == 258)
//	{
//		printf("FS(%.10f, %.10f) Def(%.10f, %.10f)  [%f, %f, %f]X[%f, %f, %f] = %f [FS: %i] -> (%f, %f, [%i, %i, %i], %f)\n", freeSpaceSDF, freeSpaceWeight, sdfCombined, weightCombined,
//		       gradientFreeSpace.x, gradientFreeSpace.y, gradientFreeSpace.z,
//		       gradientCombined.x, gradientCombined.y, gradientCombined.z,
//		       dot(gradientFreeSpace, gradientCombined),
//		       (freeSpaceWeight > 0
//		        and ((
//			             hasGradient and hasFreeSpaceGradient
//			             and dot(gradientFreeSpace, gradientCombined) < 0.5 // if same surface, use normal combination instead of free space (prevent dents in surface)
//			             and dot(gradientFreeSpace, gradientCombined) > -0.5 // if opposite surface, don't carve
//
//		             ) or (not hasGradient and not hasFreeSpaceGradient))
//		       ),
//		       voxelBlock[linearIdx].sdf, voxelBlock[linearIdx].w_depth,
//		       voxelBlock[linearIdx].clr.x,voxelBlock[linearIdx].clr.y, voxelBlock[linearIdx].clr.z,  voxelBlock[linearIdx].w_color
//		);
//	}
}

void ITMVisualisationEngine_CUDA::ComputeRenderingTSDF(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                       const ITMLib::ITMIntrinsics* intrinsics,
                                                       ITMRenderState* renderState)
{
	const ITMHashEntry* hashTable = scene->index.GetEntries();
	float voxelSize = scene->sceneParams->voxelSize;
	Vector2i imgSize = renderState->renderingRangeImage->noDims;
	Matrix4f M = pose->GetM();
	Vector4f projParams = intrinsics->projectionParamsSimple.all;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;
	size_t N = renderState_vh->noVisibleEntries;

	if (N == 0)
		return;

	TSDF_CUDA<ITMIndexXYZ, ITMVoxel>* renderingTSDF_device = (TSDF_CUDA<ITMIndexXYZ, ITMVoxel>*) renderingTSDF;
	if (N >= renderingTSDF->allocatedBlocksMax)
		renderingTSDF->resize(2 * N);
	else
		renderingTSDF->clear();
	renderingTSDF_device->allocate(renderState_vh->GetVisibleBlocks(), N);

	auto tsdf = dynamic_cast<TSDF_CUDA<ITMIndex, ITMVoxel>*>(scene->tsdf);
	dim3 gridSize(N, 1);
	dim3 blockSize(8 * 8 * 8);
	combineDirectionalTSDFViewPoint2 << < gridSize, blockSize >> > (
		renderingTSDF_device->getMap(),
		tsdf->getMap(), renderState_vh->GetVisibleBlocks(), N,
		pose->GetInvM(), scene->sceneParams->voxelSize, scene->sceneParams->mu, scene->sceneParams->maxW);
	ORcudaKernelCheck;
}

int
ITMVisualisationEngine_CUDA::CountVisibleBlocks(const Scene* scene, const ITMRenderState* renderState, int minBlockId,
                                                int maxBlockId) const
{
	const ITMRenderState_VH* renderState_vh = (const ITMRenderState_VH*) renderState;

	int noVisibleEntries = renderState_vh->noVisibleEntries;
	const int* visibleEntryIDs_device = renderState_vh->GetVisibleEntryIDs();

		ORcudaSafeCall(cudaMemset(noTotalBlocks_device, 0, sizeof(uint)));

	dim3 blockSize(256);
	dim3 gridSize((int) ceil((float) noVisibleEntries / (float) blockSize.x));

	const ITMHashEntry* hashTable_device = scene->index.GetEntries();
	countVisibleBlocks_device << < gridSize, blockSize >> >
	                                         (visibleEntryIDs_device, noVisibleEntries, hashTable_device, noTotalBlocks_device, minBlockId, maxBlockId);
	ORcudaKernelCheck;

	uint noTotalBlocks;
	ORcudaSafeCall(cudaMemcpy(&noTotalBlocks, noTotalBlocks_device, sizeof(uint), cudaMemcpyDeviceToHost));

	return noTotalBlocks;
}

void ITMVisualisationEngine_CUDA::CreateExpectedDepths(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                       const ITMIntrinsics* intrinsics,
                                                       ITMRenderState* renderState)
{
	renderingTSDFTime = 0;
	if (CombineTSDFForRendering())
	{
		Vector3f v1 = pose->GetR() * Vector3f(1, 0, 0);
		Vector3f v2 = lastTSDFCombinePose.GetR() * Vector3f(1, 0, 0);
		float relativePoseAngle = acos(MAX(MIN(dot(v1, v2), 1), -1));
		if (frameCounter < 5 // initialization phase, many changes in TSDFBase
		    or frameCounter - lastTSDFCombineFrameCounter > 50 // update sometimes, even if camera static
		    or ORUtils::length(lastTSDFCombinePose.GetT() - pose->GetT()) > 0.05 // update, if camera translates
		    or relativePoseAngle > 0.05 * M_PI_2 // update, if camera rotates
		    or true
			)
		{
			ITMTimer timer;
			timer.Tick();
			ComputeRenderingTSDF(scene, pose, intrinsics, renderState);
			renderingTSDFTime = timer.Tock();
//			printf("CombineTSDFForRendering() frames: %i\ttranslation: %f\tangle: %f\ttime: %fs\n",
//			       frameCounter - lastTSDFCombineFrameCounter,
//			       ORUtils::length(lastTSDFCombinePose.GetT() - pose->GetT()), relativePoseAngle, renderingTSDFTime);
			lastTSDFCombinePose = *pose;
			lastTSDFCombineFrameCounter = frameCounter;
		}
	}
	frameCounter++;

	float voxelSize = scene->sceneParams->voxelSize;

	Vector2i imgSize = renderState->renderingRangeImage->noDims;
	Vector2f* minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	init.x = FAR_AWAY;
	init.y = VERY_CLOSE;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->dataSize);

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;

	//go through list of visible 8x8x8 blocks, project to image plane, create list of 16x16 rendering blocks
	{
		int noVisibleEntries = renderState_vh->noVisibleEntries;
		if (noVisibleEntries == 0) return;

		dim3 blockSize(256);
		dim3 gridSize((int) ceil((float) noVisibleEntries / (float) blockSize.x));
		ORcudaSafeCall(cudaMemset(noTotalBlocks_device, 0, sizeof(uint)));
		projectAndSplitBlocks_device << <gridSize, blockSize >> > (
			renderingBlockList_device, noTotalBlocks_device, renderState_vh->GetVisibleBlocks(),
				noVisibleEntries, pose->GetM(), intrinsics->projectionParamsSimple.all, imgSize, voxelSize);
		ORcudaKernelCheck;
	}

	uint noTotalBlocks;
	ORcudaSafeCall(cudaMemcpy(&noTotalBlocks, noTotalBlocks_device, sizeof(uint), cudaMemcpyDeviceToHost));
	if (noTotalBlocks == 0) return;
	if (noTotalBlocks > (unsigned) MAX_RENDERING_BLOCKS) noTotalBlocks = MAX_RENDERING_BLOCKS;

	// go through rendering blocks, compute per pixel min/max z value for faster raycasting
	{
		// fill minmaxData
		dim3 blockSize(16, 16);
		dim3 gridSize((unsigned int) ceil((float) noTotalBlocks / 4.0f), 4);
		computeMinMaxData_device << < gridSize, blockSize >> > (noTotalBlocks, renderingBlockList_device, imgSize, minmaxData);
		ORcudaKernelCheck;
	}
}


void ITMVisualisationEngine_CUDA::GenericRaycast(const Scene* scene, const Vector2i& imgSize, const Matrix4f& invM,
                                                 const Vector4f& projParams, const ITMRenderState* renderState,
                                                 bool updateVisibleList) const
{
	HashEntryVisibilityType* entriesVisibleType = NULL;
	if (updateVisibleList && (dynamic_cast<const ITMRenderState_VH*>(renderState) != NULL))
	{
		entriesVisibleType = ((ITMRenderState_VH*) renderState)->GetEntriesVisibleType();
	}

		dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));
	if (this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL and DIRECTIONAL_RENDERING_MODE == 2)
	{
		InputPointClouds pointClouds;
		for (TSDFDirection_type directionIdx = 0; directionIdx < N_DIRECTIONS; directionIdx++)
		{
			pointClouds.pointCloud[directionIdx] = renderState->raycastResultDirectional[directionIdx]->GetData(
				MEMORYDEVICE_CUDA);

			genericRaycast_device<ITMIndex, ITMVoxel> << < gridSize, cudaBlockSize >> > (
				pointClouds.pointCloud[directionIdx],
					renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
					((TSDF_CUDA<ITMIndex, ITMVoxel>*) scene->tsdf)->getMap(),
					imgSize,
					invM,
					invertProjectionParams(projParams),
					*(scene->sceneParams),
					renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
					TSDFDirection(directionIdx)
			);
			ORcudaKernelCheck;

			pointClouds.pointCloudNormals[directionIdx] = renderState->raycastNormalsDirectional[directionIdx]->GetData(
				MEMORYDEVICE_CUDA);
			computePointCloudNormals_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
				pointClouds.pointCloudNormals[directionIdx],
					pointClouds.pointCloud[directionIdx],
					imgSize,
					scene->sceneParams->voxelSize
			);
			ORcudaKernelCheck;
		}

//		combineDirectionalPointClouds_device<ITMIndex, ITMVoxel> << < gridSize, cudaBlockSize >> > (
//			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
//				renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA),
//				pointClouds,
//				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
//				entriesVisibleType,
//				((TSDF_CUDA<ITMIndex, ITMVoxel>*) scene->tsdf)->getMap(),
//				imgSize,
//				invM,
//				invertProjectionParams(projParams),
//				*(scene->sceneParams),
//				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA)
//		);
//		ORcudaKernelCheck;
	}
	else if (this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL and DIRECTIONAL_RENDERING_MODE == 1)
	{
//		genericRaycastCombinedTSDF_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
//			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
//				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
//				entriesVisibleType,
//				scene->localVBA.GetVoxelBlocks(),
//				scene->index.getIndexData(),
//				*combinedTSDF_device,
//				imgSize,
//				invM,
//				invertProjectionParams(projParams),
//				*(scene->sceneParams),
//				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
//				this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL
//		);
//		ORcudaKernelCheck;

//		genericRaycastRenderingTSDF_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
//			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
//				*renderingTSDF,
//				imgSize, invM, invertProjectionParams(projParams),
//				*(scene->sceneParams), renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA)
//		);
//		ORcudaKernelCheck;

		genericRaycast_device << < gridSize, cudaBlockSize >> > (
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
				dynamic_cast<TSDF_CUDA<ITMIndexXYZ, ITMVoxel>*> (renderingTSDF)->getMap(),
				imgSize,
				invM,
				invertProjectionParams(projParams),
				*(scene->sceneParams),
				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA)
		);
		ORcudaKernelCheck;

		computePointCloudNormals_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
			renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				imgSize, scene->sceneParams->voxelSize);
		ORcudaKernelCheck;
	}
	else
	{
		genericRaycast_device << < gridSize, cudaBlockSize >> > (
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
				((TSDF_CUDA<ITMIndex, ITMVoxel>*) scene->tsdf)->getMap(),
				imgSize,
				invM,
				invertProjectionParams(projParams),
				*(scene->sceneParams),
				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
				TSDFDirection::NONE
		);
		ORcudaKernelCheck;

		computePointCloudNormals_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
			renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				imgSize, scene->sceneParams->voxelSize);
		ORcudaKernelCheck;
	}
}


void ITMVisualisationEngine_CUDA::RenderImage(const Scene* scene,
                                              const ORUtils::SE3Pose* pose,
                                              const ITMIntrinsics* intrinsics,
                                              const ITMRenderState* renderState,
                                              ITMUChar4Image* outputImage,
                                              IITMVisualisationEngine::RenderImageType type,
                                              IITMVisualisationEngine::RenderRaycastSelection raycastType) const
{
	Vector2i imgSize = outputImage->noDims;
	Matrix4f invM = pose->GetInvM();

	bool useDirectional = this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL;

	Vector4f* pointsRay, * normalsRay;
	if (raycastType == IITMVisualisationEngine::RENDER_FROM_OLD_RAYCAST)
	{
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	} else if (raycastType == IITMVisualisationEngine::RENDER_FROM_OLD_FORWARDPROJ)
	{
		pointsRay = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	} else
	{
		GenericRaycast(scene, imgSize, invM, intrinsics->projectionParamsSimple.all, renderState, false);
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	}
	normalsRay = renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA);

	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;

	Vector4u* outRendering = outputImage->GetData(MEMORYDEVICE_CUDA);

	Vector6f* directionalContribution = nullptr;
	const ITMVoxel *voxelData = scene->localVBA.GetVoxelBlocks();
	const ITMVoxelIndex::IndexData* voxelIndex = scene->index.getIndexData();
	if (useDirectional and not CombineTSDFForRendering())
	{
		directionalContribution = renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA);
	}

	TSDF_CUDA<ITMIndexXYZ, ITMVoxel>* renderingTSDF_device = (TSDF_CUDA<ITMIndexXYZ, ITMVoxel>*) renderingTSDF;
	TSDF_CUDA<ITMIndex , ITMVoxel>* tsdf_device = (TSDF_CUDA<ITMIndex, ITMVoxel>*) scene->tsdf;

	dim3 cudaBlockSize(8, 8);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));

	if ((type == IITMVisualisationEngine::RENDER_COLOUR_FROM_VOLUME) &&
	    (!ITMVoxel::hasColorInformation))
		type = IITMVisualisationEngine::RENDER_SHADED_GREYSCALE;

	switch (type)
	{
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_VOLUME:
			if (CombineTSDFForRendering())
			{
				renderColour_device << < gridSize, cudaBlockSize >> > (outRendering, pointsRay,
				  renderingTSDF_device->getMap(),
					imgSize, lightSource);
				ORcudaKernelCheck;
			}
			else
			{
				renderColour_device << < gridSize, cudaBlockSize >> > (outRendering, pointsRay,
					tsdf_device->getMap(),
					imgSize, lightSource);
			}
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_SDFNORMAL:
			renderColourFromNormals_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			(outRendering, pointsRay,
				directionalContribution,
				voxelData, voxelIndex,
				imgSize, lightSource);
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_IMAGENORMAL:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderNormals_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                       (outRendering, pointsRay, normalsRay, imgSize, scene->sceneParams->voxelSize, lightSource);
			} else
			{
				renderNormals_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                        (outRendering, pointsRay, normalsRay, imgSize, scene->sceneParams->voxelSize, lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_CONFIDENCE_SDFNORMAL:
			renderColourFromConfidence_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			                                                                          (outRendering, pointsRay,
				                                                                          directionalContribution,
				                                                                          voxelData, voxelIndex,
				                                                                          imgSize, *(scene->sceneParams), lightSource);
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_CONFIDENCE_IMAGENORMAL:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderConfidence_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                          (outRendering, pointsRay, normalsRay, imgSize, *(scene->sceneParams), lightSource);
			} else
			{
				renderConfidence_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                           (outRendering, pointsRay, normalsRay, imgSize, *(scene->sceneParams), lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_DEPTH:
			renderDepth_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			                                                           (outRendering, pointsRay, pose->GetM(), imgSize, scene->sceneParams->voxelSize, scene->sceneParams->viewFrustum_max);
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_SHADED_GREYSCALE_IMAGENORMALS:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderGrey_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                    (outRendering, pointsRay, normalsRay, scene->sceneParams->voxelSize, imgSize, lightSource);
			} else
			{
				renderGrey_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                     (outRendering, pointsRay, normalsRay, scene->sceneParams->voxelSize, imgSize, lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_SHADED_GREYSCALE:
		default:
			if (CombineTSDFForRendering())
			{
				ORcudaKernelCheck;
				renderGrey_device << < gridSize, cudaBlockSize >> > (
					outRendering, pointsRay,
					renderingTSDF_device->getMap(),
					imgSize, lightSource);
				ORcudaKernelCheck;
			}
			else
			{
				ORcudaKernelCheck;
				renderGrey_device << < gridSize, cudaBlockSize >> > (
					outRendering, pointsRay,
						tsdf_device->getMap(),
						imgSize, lightSource);
				ORcudaKernelCheck;
			}
			break;
	}
}

void ITMVisualisationEngine_CUDA::ForwardRender(const Scene* scene,
                                                const ITMView* view,
                                                ITMTrackingState* trackingState,
                                                ITMRenderState* renderState) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f M = trackingState->pose_d->GetM();
	Matrix4f invM = trackingState->pose_d->GetInvM();
	const Vector4f& projParams = view->calib.intrinsics_d.projectionParamsSimple.all;

	const Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	float* currentDepth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* forwardProjection = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	int* fwdProjMissingPoints = renderState->fwdProjMissingPoints->GetData(MEMORYDEVICE_CUDA);
	const Vector2f* minmaximg = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);
	float voxelSize = scene->sceneParams->voxelSize;
	const ITMVoxel* voxelData = scene->localVBA.GetVoxelBlocks();
	const typename ITMVoxelIndex::IndexData* voxelIndex = scene->index.getIndexData();

	renderState->forwardProjection->Clear();

	dim3 blockSize, gridSize;

	{ // forward projection
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x),
		                (int) ceil((float) imgSize.y / (float) blockSize.y));

		forwardProject_device << < gridSize, blockSize >> >
		                                     (forwardProjection, pointsRay, imgSize, M, projParams, voxelSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemset(noTotalPoints_device, 0, sizeof(uint)));

	{ // find missing points
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x),
		                (int) ceil((float) imgSize.y / (float) blockSize.y));

		findMissingPoints_device << < gridSize, blockSize >> > (fwdProjMissingPoints, noTotalPoints_device, minmaximg,
			forwardProjection, currentDepth, imgSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(
		cudaMemcpy(&renderState->noFwdProjMissingPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));

	{ // render missing points
		blockSize = dim3(256);
		gridSize = dim3((int) ceil((float) renderState->noFwdProjMissingPoints / blockSize.x));

		genericRaycastMissingPoints_device<ITMVoxel, ITMVoxelIndex> << < gridSize, blockSize >> > (
			forwardProjection,
				nullptr,
				nullptr,
				voxelData,
				voxelIndex,
				imgSize,
				invM,
				invertProjectionParams(projParams),
				fwdProjMissingPoints, renderState->noFwdProjMissingPoints,
				*(scene->sceneParams), minmaximg,
				this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL
		);
		ORcudaKernelCheck;
	}
}

void ITMVisualisationEngine_CUDA::CreatePointCloud(const Scene* scene,
                                                   const ITMView* view,
                                                   ITMTrackingState* trackingState,
                                                   ITMRenderState* renderState,
                                                   bool skipPoints) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM() * view->calib.trafo_rgb_to_depth.calib;

	bool useDirectial = this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL;

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_rgb.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	ORcudaSafeCall(cudaMemsetAsync(noTotalPoints_device, 0, sizeof(uint)));

	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;
	Vector4f* locations = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* colours = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);

	dim3 cudaBlockSize(16, 16);
	dim3 gridSize = getGridSize(imgSize, cudaBlockSize);
	if (this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL and DIRECTIONAL_RENDERING_MODE == 1)
	{
		renderPointCloud_device << < gridSize, cudaBlockSize >> > (locations, colours, noTotalPoints_device, pointsRay,
			renderingTSDF->toCUDA()->getMap(),
			skipPoints, scene->sceneParams->voxelSize, imgSize, lightSource);
	}
	else
	{
		renderPointCloud_device << < gridSize, cudaBlockSize >> > (locations, colours, noTotalPoints_device, pointsRay,
			renderingTSDF->toCUDA()->getMap(),
			skipPoints, scene->sceneParams->voxelSize, imgSize, lightSource);
	}
	ORcudaKernelCheck;

	ORcudaSafeCall(
		cudaMemcpy(&trackingState->pointCloud->noTotalPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));
}

void ITMVisualisationEngine_CUDA::FindSurface(const Scene* scene,
                                              const ORUtils::SE3Pose* pose,
                                              const ITMIntrinsics* intrinsics,
                                              const ITMRenderState* renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->noDims, pose->GetInvM(), intrinsics->projectionParamsSimple.all,
	               renderState, false);
}

void ITMVisualisationEngine_CUDA::CreateICPMaps(const Scene* scene,
                                                const ITMView* view,
                                                ITMTrackingState* trackingState,
                                                ITMRenderState* renderState) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM();

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_d.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	Vector4f* pointsMap = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* normalsMap = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	Vector4f* normalsRay = renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA);
	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));

	if (view->calib.intrinsics_d.FocalLengthSignsDiffer())
	{
		renderICP_device<true> << < gridSize, cudaBlockSize >> > (pointsMap, normalsMap, pointsRay, normalsRay,
			scene->sceneParams->voxelSize, imgSize, lightSource);
	} else
	{
		renderICP_device<false> << < gridSize, cudaBlockSize >> > (pointsMap, normalsMap, pointsRay, normalsRay,
			scene->sceneParams->voxelSize, imgSize, lightSource);
	}
	ORcudaKernelCheck;
}

void ITMVisualisationEngine_CUDA::RenderTrackingError(ITMUChar4Image* outRendering,
                                                      const ITMTrackingState* trackingState,
                                                      const ITMView* view) const
{
	Vector4u* data = outRendering->GetData(MEMORYDEVICE_CUDA);
	const Vector4f* pointsRay = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	const Vector4f* normalsRay = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	const float* depthImage = view->depth->GetData(MEMORYDEVICE_CUDA);
	const Matrix4f& depthImageInvPose = trackingState->pose_d->GetInvM();
	const Matrix4f& sceneRenderingPose = trackingState->pose_pointCloud->GetM();
	Vector2i imgSize = view->calib.intrinsics_d.imgSize;
	const float maxError = this->settings->sceneParams.mu;

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));
	renderPixelError_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> > (
		data, pointsRay, normalsRay, depthImage, depthImageInvPose, sceneRenderingPose,
			view->calib.intrinsics_d.projectionParamsSimple.all, imgSize, maxError);
}

} // namespace ITMLib
