// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#pragma once

#include <memory>
#include <ITMLib/Utils/ITMLibSettings.h>
#include <ITMLib/Utils/ITMSceneParams.h>
#include <ITMLib/Utils/ITMTimer.h>
#include <ITMLib/Objects/Scene/TSDF_CUDA.h>
#include "ITMSceneReconstructionEngine_CUDA.h"
#include "ITMSummingVoxelMap_CUDA.h"

#include "../Shared/ITMSceneReconstructionEngine_Shared.h"
#include "ITMLib/Objects/RenderStates/ITMRenderState_VH.h"
#include "ITMLib/Utils/ITMCUDAUtils.h"
#include <stdgpu/memory.h>
#include <stdgpu/unordered_map.cuh>
#include <stdgpu/unordered_set.cuh>

using namespace ITMLib;

namespace
{
// device functions

void
__global__
rayCastClearSum_device(
	const ITMVoxelBlockHash::IndexData *hashTable,
	const int *visibleEntryIds,
	SummingVoxel *entriesRayCasting
)
{
	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;
	int locId = x + y * SDF_BLOCK_SIZE + z * SDF_BLOCK_SIZE * SDF_BLOCK_SIZE;
	int entryId = blockIdx.x;

	const ITMHashEntry &hashEntry = hashTable[visibleEntryIds[entryId]];
	if (not hashEntry.IsValid())
		return;

	entriesRayCasting[hashEntry.ptr * SDF_BLOCK_SIZE3 + locId].reset();
}


__global__
void rayCastCombine_device(
	ITMVoxel *localVBA,
	const ITMVoxelBlockHash::IndexData *hashTable,
	const int *visibleEntryIds,
	const SummingVoxel *summingVoxels,
	const ITMSceneParams sceneParams
)
{
	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;
	int locId = VoxelIndicesToOffset(x, y, z);
	size_t entryId = blockIdx.x;

	const ITMHashEntry &hashEntry = hashTable[visibleEntryIds[entryId]];
	if (not hashEntry.IsValid())
		return;

	ITMVoxel *localVoxelBlock = &(localVBA[hashEntry.ptr * SDF_BLOCK_SIZE3]);

	// assumption: summingVoxels added in visibleEntryIds order (valid for ITMSummingVoxelMap_CUDA)
	const SummingVoxel *rayCastingSum = &(summingVoxels[entryId * SDF_BLOCK_SIZE3]);

	rayCastCombine(localVoxelBlock[locId], rayCastingSum[locId], sceneParams);
}

__global__
void rayCastUpdate_device(
	Vector2i imgSize_d, Vector2i imgSize_rgb, float* depth, Vector4f* depthNormals, Vector4u* rgb,
	const Matrix4f invM_d, const Matrix4f invM_rgb,
	const Vector4f invProjParams_d, const Vector4f invProjParams_rgb,
	const ITMFusionParams fusionParams,
	const ITMSceneParams sceneParams,
	stdgpu::unordered_map<IndexType, SummingVoxel*> summingVoxelMap
	)
{
	int x = threadIdx.x + blockIdx.x * blockDim.x;
	int y = threadIdx.y + blockIdx.y * blockDim.y;

	if (x >= imgSize_d.x or y >= imgSize_d.y)
		return;

	rayCastUpdate(x, y, imgSize_d, imgSize_rgb, depth, depthNormals, rgb, invM_d, invM_rgb,
	              invProjParams_d, invProjParams_rgb, fusionParams, sceneParams, summingVoxelMap);
}

__global__
void rayCastCarveSpace_device(
	Vector2i imgSize, float* depth, Vector4f* depthNormals,
	const Matrix4f invM_d,
	const Vector4f invProjParams_d, const Vector4f invProjParams_rgb,
	const ITMFusionParams fusionParams,
	const ITMSceneParams sceneParams,
	const ITMHashEntry* hashTable,
	stdgpu::unordered_map<IndexType, SummingVoxel*> summingVoxelMap,
	ITMVoxel *localVBA)
{
	int x = threadIdx.x + blockIdx.x * blockDim.x;
	int y = threadIdx.y + blockIdx.y * blockDim.y;

	if (x >= imgSize.x or y >= imgSize.y)
		return;

	rayCastCarveSpace(x, y, imgSize, depth, depthNormals, invM_d,
	                  invProjParams_d, invProjParams_rgb, fusionParams, sceneParams,
	                  hashTable, summingVoxelMap, localVBA);
}

template<bool stopMaxW>
__global__ void voxelProjectionCarveSpace_device(
	ITMVoxel *localVBA, SummingVoxel* summingVoxels,
	const ITMHashEntry *hashTable, int *visibleEntryIDs,
	const Vector4u *rgb, Vector2i rgbImgSize, const float *depth, const Vector4f *depthNormals,
	const float *confidence, Vector2i depthImgSize, Matrix4f M_d, Matrix4f M_rgb, Vector4f projParams_d,
	Vector4f projParams_rgb, const ITMFusionParams fusionParams,
	const ITMSceneParams sceneParams)
{
	Vector3i globalPos;
	int entryId = blockIdx.x;

	const ITMHashEntry &currentHashEntry = hashTable[visibleEntryIDs[entryId]];

	if (currentHashEntry.ptr < 0) return;

	globalPos = currentHashEntry.pos.toInt() * SDF_BLOCK_SIZE;

	ITMVoxel *localVoxelBlock = &(localVBA[currentHashEntry.ptr * SDF_BLOCK_SIZE3]);

	// assumption: summingVoxels added in visibleEntryIds order (valid for ITMSummingVoxelMap_CUDA)
	SummingVoxel *localRayCastingSum = &(summingVoxels[entryId * SDF_BLOCK_SIZE3]);

	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;

	Vector4f pt_model; int locId;

	locId = x + y * SDF_BLOCK_SIZE + z * SDF_BLOCK_SIZE * SDF_BLOCK_SIZE;

	if (stopMaxW) if (localVoxelBlock[locId].w_depth == sceneParams.maxW) return;
	//if (approximateIntegration) if (localVoxelBlock[locId].w_depth != 0) return;

	float voxelSize = sceneParams.voxelSize;
	pt_model.x = (float)(globalPos.x + x) * voxelSize;
	pt_model.y = (float)(globalPos.y + y) * voxelSize;
	pt_model.z = (float)(globalPos.z + z) * voxelSize;
	pt_model.w = 1.0f;

	voxelProjectionCarveSpace(
		localVoxelBlock[locId], localRayCastingSum[locId],
		TSDFDirection(currentHashEntry.direction),
		pt_model, M_d, projParams_d, M_rgb, projParams_rgb,
		fusionParams, sceneParams, depth, depthNormals, confidence,
		depthImgSize, rgb, rgbImgSize);
}

template<bool stopMaxW>
__global__ void integrateIntoScene_device(stdgpu::unordered_map<ITMIndexDirectional, ITMVoxel*> tsdf, ITMIndexDirectional* visibleEntries,
                                          const Vector4u* rgb, Vector2i rgbImgSize, const float* depth,
                                          const Vector4f* depthNormals, const float* confidence, Vector2i depthImgSize,
                                          Matrix4f M_d, Matrix4f M_rgb, Vector4f projParams_d, Vector4f projParams_rgb,
                                          float _voxelSize, const ITMFusionParams fusionParams,
                                          const ITMSceneParams sceneParams)
{
	const ITMIndexDirectional& index = visibleEntries[blockIdx.x];
	auto it = tsdf.find(index);
	if (it == tsdf.end())
		return;
	ITMVoxel *localVoxelBlock = it->second;
	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;

	Vector4f pt_model; int locId;

	locId = x + y * SDF_BLOCK_SIZE + z * SDF_BLOCK_SIZE * SDF_BLOCK_SIZE;

	if (stopMaxW) if (localVoxelBlock[locId].w_depth == sceneParams.maxW) return;

	pt_model = Vector4f(voxelIdxToWorldPos(index.getPosition() * SDF_BLOCK_SIZE + Vector3i(x, y, z), _voxelSize), 1.0f);

	std::conditional<ITMVoxel::hasColorInformation, ComputeUpdatedVoxelInfo<true, ITMVoxel>, ComputeUpdatedVoxelInfo<false, ITMVoxel>>::type::compute(
		localVoxelBlock[locId], index.getDirection(),
		pt_model, M_d, projParams_d, M_rgb, projParams_rgb, fusionParams, sceneParams, depth, depthNormals, confidence,
		depthImgSize, rgb, rgbImgSize);
}

template<bool stopMaxW>
__global__ void integrateIntoScene_device(ITMVoxel *localVBA, const ITMHashEntry *hashTable, int *visibleEntryIDs,
	const Vector4u *rgb, Vector2i rgbImgSize, const float *depth, const Vector4f *depthNormals, const float *confidence, Vector2i depthImgSize, Matrix4f M_d, Matrix4f M_rgb, Vector4f projParams_d,
	Vector4f projParams_rgb, float _voxelSize, const ITMFusionParams fusionParams, const ITMSceneParams sceneParams)
{
	Vector3i globalPos;
	int entryId = visibleEntryIDs[blockIdx.x];

	const ITMHashEntry &currentHashEntry = hashTable[entryId];

	if (currentHashEntry.ptr < 0) return;

	globalPos = blockToVoxelPos(currentHashEntry.pos.toInt());

	ITMVoxel *localVoxelBlock = &(localVBA[currentHashEntry.ptr * SDF_BLOCK_SIZE3]);

	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;

	Vector4f pt_model; int locId;

	locId = x + y * SDF_BLOCK_SIZE + z * SDF_BLOCK_SIZE * SDF_BLOCK_SIZE;

	if (stopMaxW) if (localVoxelBlock[locId].w_depth == sceneParams.maxW) return;
	//if (approximateIntegration) if (localVoxelBlock[locId].w_depth != 0) return;

	pt_model = Vector4f(voxelIdxToWorldPos(globalPos + Vector3i(x, y, z), _voxelSize), 1.0f);

		std::conditional<ITMVoxel::hasColorInformation, ComputeUpdatedVoxelInfo<true, ITMVoxel>, ComputeUpdatedVoxelInfo<false, ITMVoxel>>::type::compute(
			localVoxelBlock[locId], TSDFDirection(currentHashEntry.direction),
		pt_model, M_d, projParams_d, M_rgb, projParams_rgb, fusionParams, sceneParams, depth, depthNormals, confidence,
		depthImgSize, rgb, rgbImgSize);
}

template<template<typename...> class Set, typename... Args>
__global__ void findAllocationBlocks_device(Set<ITMIndexDirectional, Args...> visibleBlocks,
                                                    const float* depth, const Vector4f* depthNormal,
                                                    Matrix4f invM_d, Vector4f projParams_d, float mu, Vector2i imgSize, float voxelSize,
                                                    float viewFrustum_min, float viewFrustum_max, const ITMFusionParams fusionParams)
{
	int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;
	if (x > imgSize.x - 1 || y > imgSize.y - 1) return;

	findAllocationBlocks<Set, Args...>(visibleBlocks, x, y, depth, depthNormal, invM_d, projParams_d, mu, imgSize, voxelSize,
	                        viewFrustum_min, viewFrustum_max, fusionParams);
}

__global__ void buildHashAllocAndVisibleType_device(HashEntryAllocType *entriesAllocType, HashEntryVisibilityType *entriesVisibleType,
	                                                  Vector4s *blockCoords, TSDFDirection *blockDirections, const float *depth,
	                                                  const Vector4f *depthNormal, Matrix4f invM_d, Vector4f projParams_d, float mu, Vector2i _imgSize,
	                                                  float _voxelSize, ITMHashEntry *hashTable, float viewFrustum_min, float viewFrustum_max,
	                                                  const ITMFusionParams fusionParams)
{
	int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;

	if (x > _imgSize.x - 1 || y > _imgSize.y - 1) return;

	if (fusionParams.useSpaceCarving)
		buildSpaceCarvingVisibleType(entriesVisibleType, x, y, blockCoords, blockDirections,
		                             depth, depthNormal, invM_d, projParams_d, mu, _imgSize, _voxelSize, hashTable,
		                             viewFrustum_min, viewFrustum_max, fusionParams);

	buildHashAllocAndVisibleType(entriesAllocType, entriesVisibleType, x, y, blockCoords, blockDirections,
		depth, depthNormal, invM_d, projParams_d, mu, _imgSize, _voxelSize, hashTable, viewFrustum_min,
		viewFrustum_max, fusionParams);
}

__global__ void setToType3(HashEntryVisibilityType *entriesVisibleType, int *visibleEntryIDs, int noVisibleEntries)
{
	int entryId = threadIdx.x + blockIdx.x * blockDim.x;
	if (entryId > noVisibleEntries - 1) return;
	entriesVisibleType[visibleEntryIDs[entryId]] = PREVIOUSLY_VISIBLE;
}

}

ITMSceneReconstructionEngine_CUDA::ITMSceneReconstructionEngine_CUDA(
	const std::shared_ptr<const ITMLibSettings>& settings)
	: ITMSceneReconstructionEngine(settings), noFusionBlocks(0), noAllocationBlocks(0)
{

	allocationBlocksList = new ORUtils::MemoryBlock<ITMIndexDirectional>(10000, MEMORYDEVICE_CUDA);

	int noTotalEntries = ITMVoxelBlockHash::noTotalEntries;
	ORcudaSafeCall(cudaMalloc((void**) &entriesAllocType_device, noTotalEntries * sizeof(HashEntryAllocType)));
	ORcudaSafeCall(cudaMalloc((void**) &blockCoords_device, noTotalEntries * sizeof(Vector4s)));
	ORcudaSafeCall(cudaMalloc((void**) &blockDirections_device, noTotalEntries * sizeof(TSDFDirection)));

	summingVoxelMap = new SummingVoxelMap_CUDA;
}

void
ITMSceneReconstructionEngine_CUDA::IntegrateIntoSceneRayCasting(
	Scene* scene, const ITMView* view, const ITMTrackingState* trackingState,
	const ITMRenderState* renderState)
{
	ITMTimer timer;
	timer.Tick();

	Matrix4f invM_d = trackingState->pose_d->GetInvM();
	Vector4f projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
	Vector4f projParams_rgb = view->calib.intrinsics_rgb.projectionParamsSimple.all;

	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* depthNormals = view->depthNormal->GetData(MEMORYDEVICE_CUDA);
	float* confidence = view->depthConfidence->GetData(MEMORYDEVICE_CUDA);
	Vector4u* rgb = view->rgb->GetData(MEMORYDEVICE_CUDA);
	ITMVoxel* localVBA = scene->localVBA.GetVoxelBlocks();
	ITMHashEntry* hashTable = scene->index.GetEntries();

	Vector2i depthImgSize = view->depth->noDims;

	Vector4f invProjParams_d = invertProjectionParams(projParams_d);
	auto* renderState_vh = (ITMRenderState_VH*) renderState;

	/// 1. Initialize summing voxel map (allocate and reset)
	summingVoxelMap->Init(hashTable, renderState_vh->GetVisibleEntryIDs(), noFusionBlocks);

	/// 2. Ray cast update for every pixel
	dim3 blockSizeUpdate(16, 16);
	dim3 gridSizeUpdate((int) ceil((float) depthImgSize.x / (float) blockSizeUpdate.x),
	                    (int) ceil((float) depthImgSize.y / (float) blockSizeUpdate.y));
	rayCastUpdate_device << < gridSizeUpdate, blockSizeUpdate >> > (
		depthImgSize, view->rgb->noDims, depth, depthNormals, rgb, invM_d, trackingState->pose_d->GetM(),
		invProjParams_d, projParams_rgb, this->settings->fusionParams, this->settings->sceneParams,
		summingVoxelMap->getMap());
	ORcudaKernelCheck;
	this->timeStats.fusion += timer.Tock();

	/// 3. Ray cast space carving for every pixel
	timer.Tick();
	if (this->settings->fusionParams.useSpaceCarving)
	{
		if (this->settings->fusionParams.carvingMode == CarvingMode::CARVINGMODE_RAY_CASTING)
		{
			rayCastCarveSpace_device << < gridSizeUpdate, blockSizeUpdate >> > (
				depthImgSize, depth, depthNormals, invM_d, invProjParams_d, projParams_rgb, this->settings->fusionParams, this->settings->sceneParams,
					hashTable, summingVoxelMap->getMap(), localVBA);
			ORcudaKernelCheck;
		} else
		{
			Vector2i rgbImgSize = view->rgb->noDims;
			int* visibleEntryIDs = renderState_vh->GetVisibleEntryIDs();
			Matrix4f M_d = trackingState->pose_d->GetM();
			Matrix4f M_rgb = view->calib.trafo_rgb_to_depth.calib_inv * M_d;

			dim3 blockSizeVoxelProjection(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
			dim3 gridSizeVoxelProjection(noFusionBlocks);
			voxelProjectionCarveSpace_device<false> << < gridSizeVoxelProjection, blockSizeVoxelProjection >> > (
				localVBA, summingVoxelMap->getVoxels(), hashTable, visibleEntryIDs,
					rgb, rgbImgSize, depth, depthNormals,
					confidence, depthImgSize, M_d, M_rgb, projParams_d,
					projParams_rgb, this->settings->fusionParams,
					this->settings->sceneParams);
			ORcudaKernelCheck;
		}
	}
	this->timeStats.carving = timer.Tock();

	/// 4. Collect per summation voxels, update actual voxel
	timer.Tick();
	dim3 blockSizeCombine(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
	dim3 gridSizeCombine(noFusionBlocks);
	rayCastCombine_device << < gridSizeCombine, blockSizeCombine >> > (
		localVBA,
			hashTable,
			renderState_vh->GetVisibleEntryIDs(),
			summingVoxelMap->getVoxels(),
			this->settings->sceneParams
	);
	ORcudaKernelCheck;

	this->timeStats.fusion += timer.Tock();
}

ITMSceneReconstructionEngine_CUDA::~ITMSceneReconstructionEngine_CUDA(void)
{
	ORcudaSafeCall(cudaFree(entriesAllocType_device));
	ORcudaSafeCall(cudaFree(blockCoords_device));
	ORcudaSafeCall(cudaFree(blockDirections_device));
	delete summingVoxelMap;
}

void ITMSceneReconstructionEngine_CUDA::ResetScene(Scene* scene)
{
	scene->tsdf->clear();
}

struct copyIndexPosition
{
	__host__ __device__ const ITMIndex &operator()(const ITMIndexDirectional &x) const {return ITMIndex(x.getPosition().toShort());}
};

void ITMSceneReconstructionEngine_CUDA::AllocateSceneFromDepth(Scene* scene,
                                                               const ITMView* view,
                                                               const ITMTrackingState* trackingState,
                                                               const ITMRenderState* renderState,
                                                               bool onlyUpdateVisibleList, bool resetVisibleList)
{
	ITMTimer timer;
	timer.Tick();
	Vector2i depthImgSize = view->depth->noDims;
	float voxelSize = scene->sceneParams->voxelSize;

	Matrix4f M_d, invM_d;
	Vector4f projParams_d, invProjParams_d;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;

	if (resetVisibleList) renderState_vh->noVisibleEntries = 0;

	M_d = trackingState->pose_d->GetM();
	M_d.inv(invM_d);

	projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
	invProjParams_d = invertProjectionParams(projParams_d);

	float mu = scene->sceneParams->mu;

	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* depthNormal = view->depthNormal->GetData(MEMORYDEVICE_CUDA);
	int* voxelAllocationList = scene->localVBA.GetAllocationList();
	int* excessAllocationList = scene->index.GetExcessAllocationList();
	ITMHashEntry* hashTable = scene->index.GetEntries();
	ITMHashSwapState* swapStates = scene->globalCache != NULL ? scene->globalCache->GetSwapStates(true) : 0;

	int noTotalEntries = scene->index.noTotalEntries;

	int* visibleEntryIDs = renderState_vh->GetVisibleEntryIDs();
	HashEntryVisibilityType* entriesVisibleType = renderState_vh->GetEntriesVisibleType();

	dim3 cudaBlockSizeHV(16, 16);
	dim3 gridSizeHV((int) ceil((float) depthImgSize.x / (float) cudaBlockSizeHV.x),
	                (int) ceil((float) depthImgSize.y / (float) cudaBlockSizeHV.y));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) noTotalEntries / (float) cudaBlockSizeAL.x));

	dim3 cudaBlockSizeVS(256, 1);
	dim3 gridSizeVS((int) ceil((float) renderState_vh->noVisibleEntries / (float) cudaBlockSizeVS.x));

	if (scene->tsdf->size() >= scene->tsdf->allocatedBlocksMax)
	{
		printf("No more free blocks. Allocation stopped.\n");
	}
	ORcudaSafeCall(cudaMemsetAsync(entriesAllocType_device, 0, sizeof(unsigned char) * noTotalEntries));

	{
		stdgpu::unordered_set<ITMIndexDirectional> allocationBlocks = stdgpu::unordered_set<ITMIndexDirectional>::createDeviceObject(1e6);
		findAllocationBlocks_device<<<gridSizeHV, cudaBlockSizeHV>>>(allocationBlocks, depth, depthNormal, invM_d,
		                                                             invProjParams_d, mu, depthImgSize, voxelSize,
		                                                             scene->sceneParams->viewFrustum_min,
		                                                             scene->sceneParams->viewFrustum_max,
		                                                             this->settings->fusionParams);
		ORcudaKernelCheck;
		size_t N = allocationBlocks.size();
		if (N > allocationBlocksList->dataSize)
			allocationBlocksList->Resize(N);
		noAllocationBlocks = N;
		thrust::copy(allocationBlocks.device_range().begin(), allocationBlocks.device_range().end(), stdgpu::device_begin(allocationBlocksList->GetData(MEMORYDEVICE_CUDA)));

		auto tsdf = dynamic_cast<TSDF_CUDA<ITMIndexDirectional, ITMVoxel>*>(scene->tsdf);
		tsdf->allocate(allocationBlocksList->GetData(MEMORYDEVICE_CUDA), N);

		stdgpu::unordered_set<ITMIndexDirectional>::destroyDeviceObject(allocationBlocks);
	}
	this->timeStats.allocation += timer.Tock();
}

void ITMSceneReconstructionEngine_CUDA::IntegrateIntoSceneVoxelProjection(
	Scene* scene, const ITMView* view,
	const ITMTrackingState* trackingState, const ITMRenderState* renderState)
{
	ITMTimer timer;
	timer.Tick();

	Vector2i rgbImgSize = view->rgb->noDims;
	Vector2i depthImgSize = view->depth->noDims;
	float voxelSize = scene->sceneParams->voxelSize;

	Matrix4f M_d, M_rgb;
	Vector4f projParams_d, projParams_rgb;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;
	if (noFusionBlocks == 0) return;

	M_d = trackingState->pose_d->GetM();
	if (ITMVoxel::hasColorInformation) M_rgb = view->calib.trafo_rgb_to_depth.calib_inv * M_d;

	projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
	projParams_rgb = view->calib.intrinsics_rgb.projectionParamsSimple.all;

	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* depthNormals = nullptr;
	if (this->settings->fusionParams.useWeighting or
	    this->settings->fusionParams.fusionMetric == FUSIONMETRIC_POINT_TO_PLANE)
		depthNormals = view->depthNormal->GetData(MEMORYDEVICE_CUDA);
	float* confidence = view->depthConfidence->GetData(MEMORYDEVICE_CUDA);
	Vector4u* rgb = view->rgb->GetData(MEMORYDEVICE_CUDA);
	ITMVoxel* localVBA = scene->localVBA.GetVoxelBlocks();
	ITMHashEntry* hashTable = scene->index.GetEntries();

	int* visibleEntryIDs = renderState_vh->GetVisibleEntryIDs();
	stdgpu::unordered_map<ITMIndexDirectional, ITMVoxel*> tsdf = ((TSDF_CUDA<ITMIndexDirectional, ITMVoxel>*)scene->tsdf)->getMap();

	dim3 cudaBlockSize(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
	dim3 gridSize(noFusionBlocks);

	if (scene->sceneParams->stopIntegratingAtMaxW)
	{
		integrateIntoScene_device<true> << < gridSize, cudaBlockSize >> > (tsdf, allocationBlocksList->GetData(MEMORYDEVICE_CUDA),
			rgb, rgbImgSize, depth, depthNormals, confidence, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize,
			this->settings->fusionParams, this->settings->sceneParams);
		ORcudaKernelCheck;
	} else
	{
		integrateIntoScene_device<false> << < gridSize, cudaBlockSize >> > (tsdf, allocationBlocksList->GetData(MEMORYDEVICE_CUDA),
			rgb, rgbImgSize, depth, depthNormals, confidence, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize,
			this->settings->fusionParams, this->settings->sceneParams);
		ORcudaKernelCheck;
	}

	this->timeStats.fusion = timer.Tock();
}

struct findVisibleBlocksFunctor
{
	findVisibleBlocksFunctor(stdgpu::unordered_set<ITMIndex> visibleBlocks,
	                         ITMIndexDirectional* fusionBlocksList,
	                         size_t fusionBlocksListSize,
	                         unsigned long long* fusionBlocksCounter,
	                         Matrix4f pose_M,
	                         Vector4f projParams,
	                         Vector2i imgSize,
	                         ITMSceneParams sceneParams) :
		visibleBlocks(visibleBlocks), fusionBlocksList(fusionBlocksList), fusionBlocksListSize(fusionBlocksListSize),
		fusionBlocksCounter(fusionBlocksCounter), pose_M(pose_M), projParams(projParams), imgSize(imgSize), sceneParams(sceneParams)
	{}

	__device__
	void operator()(thrust::pair<ITMIndexDirectional , ITMVoxel*> block)
	{

		int in_offset = threadIdx.x + blockDim.x * blockIdx.x;

		const Vector3s blockIdx = block.first.getPosition().toShort();

		float dist = (pose_M * Vector4f(blockIdx.toFloat() * 8 * sceneParams.voxelSize, 1)).z;
		if (dist > 8) return;

		bool isVisible, isVisibleEnlarged;
		checkBlockVisibility<true>(isVisible, isVisibleEnlarged, blockIdx, pose_M, projParams, sceneParams.voxelSize, imgSize);

		if (isVisibleEnlarged)
		{
			visibleBlocks.insert(blockIdx);
		}
		if (isVisible and dist <= sceneParams.viewFrustum_max + 8 * sceneParams.voxelSize)
		{
			unsigned long long offset = atomicAdd(fusionBlocksCounter, 1);
			if (offset > fusionBlocksListSize)
				return;
			fusionBlocksList[offset] = block.first;
		}
	}

	stdgpu::unordered_set<ITMIndex> visibleBlocks;
	ITMIndexDirectional* fusionBlocksList;
	size_t fusionBlocksListSize;
	unsigned long long* fusionBlocksCounter;
	Matrix4f pose_M;
	Vector4f projParams;
	Vector2i imgSize;
	ITMSceneParams sceneParams;
};

void ITMSceneReconstructionEngine_CUDA::FindVisibleBlocks(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                    const ITMIntrinsics* intrinsics, ITMRenderState* renderState)
{
	ITMTimer timer;
	timer.Tick();
	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;
	auto tsdf = dynamic_cast<TSDF_CUDA<ITMIndexDirectional, ITMVoxel>*>(scene->tsdf)->getMap();


	stdgpu::unordered_set<ITMIndex> visibleBlocks = stdgpu::unordered_set<ITMIndex>::createDeviceObject(
		MAX(renderState_vh->AllocatedSize(), allocationBlocksList->dataSize * 2)
		);

	if (noFusionBlocks > 0.8 * allocationBlocksList->dataSize)
	{
		allocationBlocksList->Resize(2 * allocationBlocksList->dataSize);
	}
	unsigned long long* fusionBlocksCounter_device = createDeviceArray<unsigned long long>(1, 0);
	thrust::for_each(thrust::device, tsdf.device_range().begin(), tsdf.device_range().end(),
	                 findVisibleBlocksFunctor(visibleBlocks, allocationBlocksList->GetData(MEMORYDEVICE_CUDA),
	                                          allocationBlocksList->dataSize,
	                                          fusionBlocksCounter_device,
	                                          pose->GetM(),
	                                          intrinsics->projectionParamsSimple.all,
	                                          renderState->renderingRangeImage->noDims,
	                                          *(scene->sceneParams)));

	renderState_vh->Resize(visibleBlocks.size());
	thrust::copy(visibleBlocks.device_range().begin(), visibleBlocks.device_range().end(), stdgpu::device_begin(renderState_vh->GetVisibleBlocks()));

	renderState_vh->noVisibleEntries = visibleBlocks.size();
	ORcudaSafeCall(cudaMemcpy(&noFusionBlocks, fusionBlocksCounter_device, sizeof(noFusionBlocks), cudaMemcpyDeviceToHost));
	noFusionBlocks = MIN(noFusionBlocks, allocationBlocksList->dataSize);

	destroyDeviceArray(fusionBlocksCounter_device);
	stdgpu::unordered_set<ITMIndex>::destroyDeviceObject(visibleBlocks);
	timeStats.buildingVisibilityList += timer.Tock();
}
