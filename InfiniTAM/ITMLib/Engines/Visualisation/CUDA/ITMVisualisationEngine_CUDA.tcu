// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#include "ITMVisualisationEngine_CUDA.h"
#include "ITMVisualisationHelpers_CUDA.h"

#include <stdgpu/unordered_set.cuh>
#include <stdgpu/unordered_map.cuh>
#include <thrust/sequence.h>
#include <thrust/transform.h>
#include <ITMLib/Utils/ITMTimer.h>
#include <ITMLib/Engines/Reconstruction/Shared/ITMBlockTraversal.h>

namespace ITMLib
{

inline dim3 getGridSize(dim3 taskSize, dim3 blockSize)
{
	return dim3((taskSize.x + blockSize.x - 1) / blockSize.x, (taskSize.y + blockSize.y - 1) / blockSize.y,
	            (taskSize.z + blockSize.z - 1) / blockSize.z);
}

inline dim3 getGridSize(Vector2i taskSize, dim3 blockSize)
{ return getGridSize(dim3(taskSize.x, taskSize.y), blockSize); }

ITMVisualisationEngine_CUDA::ITMVisualisationEngine_CUDA(std::shared_ptr<const ITMLibSettings> settings)
	: ITMVisualisationEngine(settings)
{
	ORcudaSafeCall(cudaMalloc((void**) &renderingBlockList_device, sizeof(RenderingBlock) * MAX_RENDERING_BLOCKS));
	ORcudaSafeCall(cudaMalloc((void**) &noTotalBlocks_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**) &this->noTotalPoints_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**) &noVisibleEntries_device, sizeof(uint)));

	if (CombineTSDFForRendering())
	{
		renderIndex = new ITMVoxelBlockHash(MEMORYDEVICE_CUDA);
		renderVBA = new ITMLocalVBA<ITMVoxel>(MEMORYDEVICE_CUDA, renderIndex->getNumAllocatedVoxelBlocks(),
		                                      renderIndex->getVoxelBlockSize());
		renderVisibleEntryIDs = new ORUtils::MemoryBlock<int>(renderIndex->getNumAllocatedVoxelBlocks(), MEMORYDEVICE_CUDA);
	}
}

ITMVisualisationEngine_CUDA::~ITMVisualisationEngine_CUDA()
{
	ORcudaSafeCall(cudaFree(this->noTotalPoints_device));
	ORcudaSafeCall(cudaFree(noTotalBlocks_device));
	ORcudaSafeCall(cudaFree(renderingBlockList_device));
	ORcudaSafeCall(cudaFree(noVisibleEntries_device));
	delete renderIndex;
	delete renderVBA;
}

//ITMRenderState* ITMVisualisationEngine_CUDA::CreateRenderState(const Scene *scene, const Vector2i & imgSize) const
//{
//	return new ITMRenderState(
//		imgSize, scene->sceneParams->viewFrustum_min, scene->sceneParams->viewFrustum_max, MEMORYDEVICE_CUDA
//	);
//}

ITMRenderState_VH* ITMVisualisationEngine_CUDA::CreateRenderState(const Scene* scene, const Vector2i& imgSize) const
{
	return new ITMRenderState_VH(
		ITMVoxelBlockHash::noTotalEntries, imgSize, scene->sceneParams->viewFrustum_min,
		scene->sceneParams->viewFrustum_max, MEMORYDEVICE_CUDA
	);
}

__global__ void
combineDirectionalTSDFViewPoint(ITMVoxel* renderVoxelData, ITMHashEntry* renderHashTable, int *visibleEntryIDs,
                                const Vector3s* visibleBlocks, const stdgpu::index_t numVisibleBlocks,
                                const ITMVoxel* voxelData, const ITMHashEntry* hashTable, const Matrix4f invM,
                                const float voxelSize, const float mu, const int maxW)
{
	stdgpu::index_t i = static_cast<stdgpu::index_t>(blockIdx.x);

	if (i >= numVisibleBlocks) return;

	const Vector3s& blockPos = visibleBlocks[i];

	int hashIdx = hashIndex(blockPos);
	renderHashTable[hashIdx].pos = blockPos;
	renderHashTable[hashIdx].ptr = i;

	if (threadIdx.x == 0)
	{
		visibleEntryIDs[i] = hashIdx;
	}

	ITMVoxel *voxelBlock = renderVoxelData + i * SDF_BLOCK_SIZE3;

	int linearIdx = threadIdx.x;
	typename ITMVoxelBlockHash::IndexCache cache[N_DIRECTIONS];

	Vector3i voxelPosIdx = blockToVoxelPos(Vector3i(blockPos.x, blockPos.y, blockPos.z))
	                       + voxelOffsetToCoordinate(linearIdx);
	Vector3f voxelPos = voxelPosIdx.toFloat();

	Vector3f rayDirection = (voxelPos * voxelSize - (invM * Vector4f(0, 0, 0, 1)).toVector3()).normalised();

	Vector3f colorCombined(0, 0, 0);
	float sdfCombined = 0;
	float weightCombined = 0;
	float colorWeightCombined = 0;

	Vector3f colorCombinedNoGradient(0, 0, 0);
	float sdfCombinedNoGradient = 0;
	float weightCombinedNoGradient = 0;
	float colorWeightCombinedNoGradient = 0;

	Vector3f colorFreeSpace(0, 0, 0);
	float freeSpaceWeight = 0;
	float freeSpaceSDF = 0;

	Vector3f gradientCombined(0, 0, 0);
	Vector3f gradientFreeSpace(0, 0, 0);
	for (TSDFDirection_type directionIdx = 0; directionIdx < N_DIRECTIONS; directionIdx++)
	{
		float confidence = 0;
		int vmIndex = false;
		float sdf = readWithConfidenceFromSDF_float_uninterpolated(confidence, voxelData, hashTable, voxelPos,
		                                                           TSDFDirection(directionIdx), maxW, vmIndex,
		                                                           cache[directionIdx]);
		if (not vmIndex)
			continue;

		Vector3f color;
		float color_w = 1;
		if (RENDER_DIRECTION_COLORS == 1)
			color = TSDFDirectionColor[directionIdx];
		else
			color = readFromSDF_color4u_uninterpolated(color_w, voxelData, hashTable, voxelPos, TSDFDirection(directionIdx), cache[directionIdx], maxW).toVector3();
		Vector3f gradient = computeSingleNormalFromSDF(voxelData, hashTable, voxelPos, TSDFDirection(directionIdx), voxelSize / mu);

		float weight =
			DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx)))
			* ORUtils::dot(gradient, -rayDirection)
			* confidence;
		weight = MAX(weight, 0);

//		if (voxelPosIdx.x == -71 and voxelPosIdx.y == -24 and voxelPosIdx.z == 258)
//			printf("[%i] (%f, %f, [%f, %f, %f], %f) [%f, %f, %f] (%.12f, %.12f, %.12f) -> %.12f\n", directionIdx, sdf, confidence,
//				color.x, color.y, color.z, color_w,
//				gradient.x, gradient.y, gradient.z,
//			  DirectionAngle(gradient, TSDFDirection(directionIdx)),
//				DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx))),
//				ORUtils::dot(gradient, -rayDirection), weight);

		if (confidence > 0 and sdf > 0
		and ORUtils::length(gradient) > 0
		and false
		)
		{ // free space

			// Don't carve, if this is the "backside" of a face
			BlockTraversal bt(voxelPos * voxelSize, -rayDirection, 2 * mu, voxelSize, true);
			bool carve = true;
			while (bt.HasNextBlock())
			{
				Vector3i vIdx = bt.GetNextBlock();

				float sdf_ = readFromSDF_float_uninterpolated(voxelData, hashTable, vIdx.toFloat(), TSDFDirection(directionIdx), vmIndex, cache[directionIdx]);
				if (sdf_ < 0)
				{
					carve = false;
					break;
				}
			}

			if (carve)
			{
//				float weightFS = weight;
				float weightFS = confidence
//				                 * ORUtils::dot(-rayDirection, TSDFDirectionVector[directionIdx])

				                 * MAX(0, ORUtils::dot(gradient, TSDFDirectionVector[directionIdx]))
//				                 * DirectionWeight(DirectionAngle(gradient, TSDFDirection(directionIdx)))
				                 ;

				weightFS = MAX(weightFS, 0);

				freeSpaceSDF += weightFS * sdf;
				freeSpaceWeight += weightFS;
				colorFreeSpace += weightFS * color;
				gradientFreeSpace += weightFS * gradient;
			}
		}

		float weightNoGradient = MAX(0,
		                             confidence
		                             * ORUtils::dot(-rayDirection, TSDFDirectionVector[directionIdx])
//		                             * DirectionWeight(DirectionAngle(-rayDirection, TSDFDirection(directionIdx)))
			);
		weightCombinedNoGradient += weightNoGradient;
		sdfCombinedNoGradient += weightNoGradient * sdf;
		colorWeightCombinedNoGradient += weightNoGradient * color_w;
		colorCombinedNoGradient += weightNoGradient * color_w * color;

		sdfCombined += weight * sdf;
		weightCombined += weight;
		colorWeightCombined += weight * color_w;
		colorCombined += weight * color_w * color;
		gradientCombined += weight * gradient;
	}

	bool hasGradient = gradientCombined.x != 0 or gradientCombined.y != 0 or gradientCombined.z != 0;
	bool hasFreeSpaceGradient = gradientFreeSpace.x != 0 or gradientFreeSpace.y != 0 or gradientFreeSpace.z != 0;

	if (weightCombined > 0)
	{
		sdfCombined /= weightCombined;
		if (hasGradient) gradientCombined = gradientCombined.normalised();
	} else if (weightCombinedNoGradient > 0)
	{
		sdfCombined = sdfCombinedNoGradient / weightCombinedNoGradient;
		weightCombined = weightCombinedNoGradient;
		gradientCombined = Vector3f(0, 0, 0);
	} else
	{
		sdfCombined = 1;
		weightCombined = 0;
		gradientCombined = Vector3f(0, 0, 0);
	}

	if (colorWeightCombined > 0)
	{
		colorCombined /= colorWeightCombined;
	}
	else if (colorWeightCombinedNoGradient > 0)
	{
		colorCombined = colorCombinedNoGradient / colorWeightCombinedNoGradient;
		colorWeightCombined = colorWeightCombinedNoGradient;
	} else {
		colorCombined = Vector3f(0, 0, 0);
		colorWeightCombined = 0;
	}

	if (freeSpaceWeight > 0)
	{
		freeSpaceSDF /= freeSpaceWeight;
		colorFreeSpace /= freeSpaceWeight;
		if (hasFreeSpaceGradient)
			gradientFreeSpace = gradientFreeSpace.normalised();
	}

	if (freeSpaceWeight > 0
	    and ((hasGradient and hasFreeSpaceGradient
	          and dot(gradientFreeSpace, gradientCombined) <
	              0.707 // if same surface, use normal combination instead of free space (prevent dents in surface)
	          and dot(gradientFreeSpace, gradientCombined) > -0.707 // if opposite surface, don't carve
	         ) or (not hasGradient and not hasFreeSpaceGradient)))
	{
		voxelBlock[linearIdx].sdf = ITMVoxel::floatToValue(freeSpaceSDF);
		voxelBlock[linearIdx].w_depth = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
		voxelBlock[linearIdx].clr = TO_UCHAR3(colorFreeSpace * 255.0f);
		voxelBlock[linearIdx].w_color = ITMVoxel::floatToWeight(freeSpaceWeight, maxW);
	} else
	{
		voxelBlock[linearIdx].sdf = ITMVoxel::floatToValue(sdfCombined);
		voxelBlock[linearIdx].w_depth = ITMVoxel::floatToWeight(weightCombined, maxW);
		voxelBlock[linearIdx].clr = TO_UCHAR3(colorCombined * 255.0f);
		voxelBlock[linearIdx].w_color = ITMVoxel::floatToWeight(colorWeightCombined, maxW);
	}

//	if (voxelPosIdx.x == -71 and voxelPosIdx.y == -24 and voxelPosIdx.z == 258)
//	{
//		printf("FS(%.10f, %.10f) Def(%.10f, %.10f)  [%f, %f, %f]X[%f, %f, %f] = %f [FS: %i] -> (%f, %f, [%i, %i, %i], %f)\n", freeSpaceSDF, freeSpaceWeight, sdfCombined, weightCombined,
//		       gradientFreeSpace.x, gradientFreeSpace.y, gradientFreeSpace.z,
//		       gradientCombined.x, gradientCombined.y, gradientCombined.z,
//		       dot(gradientFreeSpace, gradientCombined),
//		       (freeSpaceWeight > 0
//		        and ((
//			             hasGradient and hasFreeSpaceGradient
//			             and dot(gradientFreeSpace, gradientCombined) < 0.5 // if same surface, use normal combination instead of free space (prevent dents in surface)
//			             and dot(gradientFreeSpace, gradientCombined) > -0.5 // if opposite surface, don't carve
//
//		             ) or (not hasGradient and not hasFreeSpaceGradient))
//		       ),
//		       voxelBlock[linearIdx].sdf, voxelBlock[linearIdx].w_depth,
//		       voxelBlock[linearIdx].clr.x,voxelBlock[linearIdx].clr.y, voxelBlock[linearIdx].clr.z,  voxelBlock[linearIdx].w_color
//		);
//	}
}

void ITMVisualisationEngine_CUDA::ComputeRenderingTSDF(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                       const ITMLib::ITMIntrinsics* intrinsics,
                                                       ITMRenderState* renderState)
{
	const ITMHashEntry* hashTable = scene->index.GetEntries();
	int noTotalEntries = scene->index.noTotalEntries;
	float voxelSize = scene->sceneParams->voxelSize;
	Vector2i imgSize = renderState->renderingRangeImage->noDims;

	Matrix4f M = pose->GetM();
	Vector4f projParams = intrinsics->projectionParamsSimple.all;

	ITMTimer timer;
	timer.Tick();
	stdgpu::index_t n = 100000;
	stdgpu::unordered_set<Vector3s> visibleBlocks = stdgpu::unordered_set<Vector3s>::createDeviceObject(n);

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) noTotalEntries / (float) cudaBlockSizeAL.x));
	findVisibleBlocks_device << < gridSizeAL, cudaBlockSizeAL >> > (visibleBlocks, hashTable, noTotalEntries,
		M, projParams, imgSize, voxelSize);
	ORcudaKernelCheck;

	stdgpu::index_t N = visibleBlocks.size();
	if (N == 0)
		return;

	Vector3s* visibleBlocksList = createDeviceArray<Vector3s>(N);
	thrust::copy(visibleBlocks.device_range().begin(), visibleBlocks.device_range().end(), stdgpu::device_begin(visibleBlocksList));

	renderIndex->Reset(); // slow, probably sufficient to clean every once in a while
	combineDirectionalTSDFViewPoint << < N, 512 >> > (renderVBA->GetVoxelBlocks(), renderIndex->GetEntries(),
		renderVisibleEntryIDs->GetData(MEMORYDEVICE_CUDA), visibleBlocksList, N,
		scene->localVBA.GetVoxelBlocks(), scene->index.GetEntries(), pose->GetInvM(), scene->sceneParams->voxelSize, scene->sceneParams->mu, scene->sceneParams->maxW);
	ORcudaKernelCheck;
//	std::cout << timer.Tock() << std::endl;

	renderNoVisibleEntries = N;

	stdgpu::unordered_set<Vector3s>::destroyDeviceObject(visibleBlocks);
	destroyDeviceArray<Vector3s>(visibleBlocksList);
}

void ITMVisualisationEngine_CUDA::FindVisibleBlocks(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                    const ITMIntrinsics* intrinsics, ITMRenderState* renderState) const
{
	const ITMHashEntry* hashTable = scene->index.GetEntries();
	int noTotalEntries = scene->index.noTotalEntries;
	float voxelSize = scene->sceneParams->voxelSize;
	Vector2i imgSize = renderState->renderingRangeImage->noDims;

	Matrix4f M = pose->GetM();
	Vector4f projParams = intrinsics->projectionParamsSimple.all;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;

	ORcudaSafeCall(cudaMemset(noVisibleEntries_device, 0, sizeof(int)));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) noTotalEntries / (float) cudaBlockSizeAL.x));
	buildCompleteVisibleList_device << < gridSizeAL, cudaBlockSizeAL >> >
	                                                 (hashTable, noTotalEntries,
		                                                 renderState_vh->GetVisibleEntryIDs(), noVisibleEntries_device, renderState_vh->GetEntriesVisibleType(), M, projParams,
		                                                 imgSize, voxelSize);
	ORcudaKernelCheck;

	/*	if (this->scene->useSwapping)
			{
			reAllocateSwappedOutVoxelBlocks_device << <gridSizeAL, cudaBlockSizeAL >> >(voxelAllocationList, hashTable, noTotalEntries,
			noAllocatedVoxelEntries_device, entriesVisibleType);
			}*/

	ORcudaSafeCall(
		cudaMemcpy(&renderState_vh->noVisibleEntries, noVisibleEntries_device, sizeof(int), cudaMemcpyDeviceToHost));
}

int
ITMVisualisationEngine_CUDA::CountVisibleBlocks(const Scene* scene, const ITMRenderState* renderState, int minBlockId,
                                                int maxBlockId) const
{
	const ITMRenderState_VH* renderState_vh = (const ITMRenderState_VH*) renderState;

	int noVisibleEntries = renderState_vh->noVisibleEntries;
	const int* visibleEntryIDs_device = renderState_vh->GetVisibleEntryIDs();

		ORcudaSafeCall(cudaMemset(noTotalBlocks_device, 0, sizeof(uint)));

	dim3 blockSize(256);
	dim3 gridSize((int) ceil((float) noVisibleEntries / (float) blockSize.x));

	const ITMHashEntry* hashTable_device = scene->index.GetEntries();
	countVisibleBlocks_device << < gridSize, blockSize >> >
	                                         (visibleEntryIDs_device, noVisibleEntries, hashTable_device, noTotalBlocks_device, minBlockId, maxBlockId);
	ORcudaKernelCheck;

	uint noTotalBlocks;
	ORcudaSafeCall(cudaMemcpy(&noTotalBlocks, noTotalBlocks_device, sizeof(uint), cudaMemcpyDeviceToHost));

	return noTotalBlocks;
}

void ITMVisualisationEngine_CUDA::CreateExpectedDepths(const Scene* scene, const ORUtils::SE3Pose* pose,
                                                       const ITMIntrinsics* intrinsics,
                                                       ITMRenderState* renderState)
{
	if (CombineTSDFForRendering())
	{
		Vector3f v1 = pose->GetR() * Vector3f(1, 0, 0);
		Vector3f v2 = lastTSDFCombinePose.GetR() * Vector3f(1, 0, 0);
		float relativePoseAngle = acos(MAX(MIN(dot(v1, v2), 1), -1));
		if (frameCounter < 10 // initialization phase, many changes in TSDF
		    or frameCounter - lastTSDFCombineFrameCounter > 50 // update sometimes, even if camera static
		    or ORUtils::length(lastTSDFCombinePose.GetT() - pose->GetT()) > 0.05 // update, if camera translates
		    or relativePoseAngle > 0.05 * M_PI_2 // update, if camera rotates
			)
		{
			printf("CombineTSDFForRendering() frames: %i\ttranslation: %f\tangle: %f\n",
			       frameCounter - lastTSDFCombineFrameCounter,
			       ORUtils::length(lastTSDFCombinePose.GetT() - pose->GetT()), relativePoseAngle);
			ComputeRenderingTSDF(scene, pose, intrinsics, renderState);
			lastTSDFCombinePose = *pose;
			lastTSDFCombineFrameCounter = frameCounter;
		}
	}
	frameCounter++;

	float voxelSize = scene->sceneParams->voxelSize;

	Vector2i imgSize = renderState->renderingRangeImage->noDims;
	Vector2f* minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	init.x = FAR_AWAY;
	init.y = VERY_CLOSE;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->dataSize);

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;

	//go through list of visible 8x8x8 blocks
	{
		const ITMHashEntry* hash_entries = CombineTSDFForRendering() ? renderIndex->GetEntries() : scene->index.GetEntries();
		const int* visibleEntryIDs = CombineTSDFForRendering() ? renderVisibleEntryIDs->GetData(MEMORYDEVICE_CUDA) : renderState_vh->GetVisibleEntryIDs();
		int noVisibleEntries = CombineTSDFForRendering() ? renderNoVisibleEntries : renderState_vh->noVisibleEntries;
		if (noVisibleEntries == 0) return;

		dim3 blockSize(256);
		dim3 gridSize((int) ceil((float) noVisibleEntries / (float) blockSize.x));
		ORcudaSafeCall(cudaMemset(noTotalBlocks_device, 0, sizeof(uint)));
		projectAndSplitBlocks_device << < gridSize, blockSize >> >
		                                            (hash_entries, visibleEntryIDs, noVisibleEntries, pose->GetM(),
			                                            intrinsics->projectionParamsSimple.all, imgSize, voxelSize, renderingBlockList_device, noTotalBlocks_device);
		ORcudaKernelCheck;
	}

	uint noTotalBlocks;
	ORcudaSafeCall(cudaMemcpy(&noTotalBlocks, noTotalBlocks_device, sizeof(uint), cudaMemcpyDeviceToHost));
	if (noTotalBlocks == 0) return;
	if (noTotalBlocks > (unsigned) MAX_RENDERING_BLOCKS) noTotalBlocks = MAX_RENDERING_BLOCKS;

	// go through rendering blocks
	{
		// fill minmaxData
		dim3 blockSize(16, 16);
		dim3 gridSize((unsigned int) ceil((float) noTotalBlocks / 4.0f), 4);
		fillBlocks_device << < gridSize, blockSize >> > (noTotalBlocks, renderingBlockList_device, imgSize, minmaxData);
		ORcudaKernelCheck;
	}
}


void ITMVisualisationEngine_CUDA::GenericRaycast(const Scene* scene, const Vector2i& imgSize, const Matrix4f& invM,
                                                 const Vector4f& projParams, const ITMRenderState* renderState,
                                                 bool updateVisibleList) const
{
	HashEntryVisibilityType* entriesVisibleType = NULL;
	if (updateVisibleList && (dynamic_cast<const ITMRenderState_VH*>(renderState) != NULL))
	{
		entriesVisibleType = ((ITMRenderState_VH*) renderState)->GetEntriesVisibleType();
	}

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));
	if (this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL and DIRECTIONAL_RENDERING_MODE == 2)
	{
		InputPointClouds pointClouds;
		for (TSDFDirection_type directionIdx = 0; directionIdx < N_DIRECTIONS; directionIdx++)
		{
			pointClouds.pointCloud[directionIdx] = renderState->raycastResultDirectional[directionIdx]->GetData(
				MEMORYDEVICE_CUDA);
			genericRaycast_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
				pointClouds.pointCloud[directionIdx],
					renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
					entriesVisibleType,
					scene->localVBA.GetVoxelBlocks(),
					scene->index.getIndexData(),
					imgSize,
					invM,
					invertProjectionParams(projParams),
					*(scene->sceneParams),
					renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
					TSDFDirection(directionIdx)
			);
			ORcudaKernelCheck;

			pointClouds.pointCloudNormals[directionIdx] = renderState->raycastNormalsDirectional[directionIdx]->GetData(
				MEMORYDEVICE_CUDA);
			computePointCloudNormals_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
				pointClouds.pointCloudNormals[directionIdx],
					pointClouds.pointCloud[directionIdx],
					imgSize,
					scene->sceneParams->voxelSize
			);
			ORcudaKernelCheck;
		}

		combineDirectionalPointClouds_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA),
				pointClouds,
				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
				entriesVisibleType,
				scene->localVBA.GetVoxelBlocks(),
				scene->index.getIndexData(),
				imgSize,
				invM,
				invertProjectionParams(projParams),
				*(scene->sceneParams),
				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA)
		);
		ORcudaKernelCheck;
	} else
	{
		genericRaycast_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA),
				entriesVisibleType,
				CombineTSDFForRendering() ? renderVBA->GetVoxelBlocks() : scene->localVBA.GetVoxelBlocks(),
				CombineTSDFForRendering() ? renderIndex->getIndexData() : scene->index.getIndexData(),
				imgSize,
				invM,
				invertProjectionParams(projParams),
				*(scene->sceneParams),
				renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
				this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL
		);
		ORcudaKernelCheck;

		computePointCloudNormals_device<ITMVoxel, ITMVoxelBlockHash> << < gridSize, cudaBlockSize >> > (
			renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA),
				renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
				imgSize, scene->sceneParams->voxelSize);
		ORcudaKernelCheck;
	}
}


void ITMVisualisationEngine_CUDA::RenderImage(const Scene* scene,
                                              const ORUtils::SE3Pose* pose,
                                              const ITMIntrinsics* intrinsics,
                                              const ITMRenderState* renderState,
                                              ITMUChar4Image* outputImage,
                                              IITMVisualisationEngine::RenderImageType type,
                                              IITMVisualisationEngine::RenderRaycastSelection raycastType) const
{
	Vector2i imgSize = outputImage->noDims;
	Matrix4f invM = pose->GetInvM();

	bool useDirectional = this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL;

	Vector4f* pointsRay, * normalsRay;
	if (raycastType == IITMVisualisationEngine::RENDER_FROM_OLD_RAYCAST)
	{
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	} else if (raycastType == IITMVisualisationEngine::RENDER_FROM_OLD_FORWARDPROJ)
	{
		pointsRay = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	} else
	{
		GenericRaycast(scene, imgSize, invM, intrinsics->projectionParamsSimple.all, renderState, false);
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	}
	normalsRay = renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA);

	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;

	Vector4u* outRendering = outputImage->GetData(MEMORYDEVICE_CUDA);

	Vector6f* directionalContribution = nullptr;
	const ITMVoxel *voxelData = scene->localVBA.GetVoxelBlocks();
	const ITMVoxelIndex::IndexData* voxelIndex = scene->index.getIndexData();
	if (useDirectional and not CombineTSDFForRendering())
	{
		directionalContribution = renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA);
	}
	if (CombineTSDFForRendering())
	{
		voxelData = renderVBA->GetVoxelBlocks();
		voxelIndex = renderIndex->GetEntries();
	}

	dim3 cudaBlockSize(8, 8);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));

	if ((type == IITMVisualisationEngine::RENDER_COLOUR_FROM_VOLUME) &&
	    (!ITMVoxel::hasColorInformation))
		type = IITMVisualisationEngine::RENDER_SHADED_GREYSCALE;

	switch (type)
	{
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_VOLUME:
			renderColour_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> > (outRendering, pointsRay,
				directionalContribution,
				voxelData, voxelIndex,
				imgSize, lightSource);
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_SDFNORMAL:
			renderColourFromNormals_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			                                                                       (outRendering, pointsRay,
				                                                                       directionalContribution,
				                                                                       voxelData, voxelIndex,
				                                                                       imgSize, lightSource);
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_IMAGENORMAL:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderNormals_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                       (outRendering, pointsRay, normalsRay, imgSize, scene->sceneParams->voxelSize, lightSource);
			} else
			{
				renderNormals_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                        (outRendering, pointsRay, normalsRay, imgSize, scene->sceneParams->voxelSize, lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_CONFIDENCE_SDFNORMAL:
			renderColourFromConfidence_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			                                                                          (outRendering, pointsRay,
				                                                                          directionalContribution,
				                                                                          voxelData, voxelIndex,
				                                                                          imgSize, *(scene->sceneParams), lightSource);
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_CONFIDENCE_IMAGENORMAL:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderConfidence_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                          (outRendering, pointsRay, normalsRay, imgSize, *(scene->sceneParams), lightSource);
			} else
			{
				renderConfidence_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                           (outRendering, pointsRay, normalsRay, imgSize, *(scene->sceneParams), lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_COLOUR_FROM_DEPTH:
			renderDepth_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
			                                                           (outRendering, pointsRay, pose->GetM(), imgSize, scene->sceneParams->voxelSize, scene->sceneParams->viewFrustum_max);
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_SHADED_GREYSCALE_IMAGENORMALS:
			if (intrinsics->FocalLengthSignsDiffer())
			{
				renderGrey_ImageNormals_device<true> << < gridSize, cudaBlockSize >> >
				                                                    (outRendering, pointsRay, normalsRay, scene->sceneParams->voxelSize, imgSize, lightSource);
			} else
			{
				renderGrey_ImageNormals_device<false> << < gridSize, cudaBlockSize >> >
				                                                     (outRendering, pointsRay, normalsRay, scene->sceneParams->voxelSize, imgSize, lightSource);
			}
			ORcudaKernelCheck;
			break;
		case IITMVisualisationEngine::RENDER_SHADED_GREYSCALE:
		default:
			renderGrey_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> > (outRendering, pointsRay,
				directionalContribution,
				voxelData, voxelIndex,
				imgSize, lightSource);
			ORcudaKernelCheck;
			break;
	}
}

void ITMVisualisationEngine_CUDA::ForwardRender(const Scene* scene,
                                                const ITMView* view,
                                                ITMTrackingState* trackingState,
                                                ITMRenderState* renderState) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f M = trackingState->pose_d->GetM();
	Matrix4f invM = trackingState->pose_d->GetInvM();
	const Vector4f& projParams = view->calib.intrinsics_d.projectionParamsSimple.all;

	const Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	float* currentDepth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* forwardProjection = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	int* fwdProjMissingPoints = renderState->fwdProjMissingPoints->GetData(MEMORYDEVICE_CUDA);
	const Vector2f* minmaximg = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);
	float voxelSize = scene->sceneParams->voxelSize;
	const ITMVoxel* voxelData = scene->localVBA.GetVoxelBlocks();
	const typename ITMVoxelIndex::IndexData* voxelIndex = scene->index.getIndexData();

	renderState->forwardProjection->Clear();

	dim3 blockSize, gridSize;

	{ // forward projection
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x),
		                (int) ceil((float) imgSize.y / (float) blockSize.y));

		forwardProject_device << < gridSize, blockSize >> >
		                                     (forwardProjection, pointsRay, imgSize, M, projParams, voxelSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemset(noTotalPoints_device, 0, sizeof(uint)));

	{ // find missing points
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x),
		                (int) ceil((float) imgSize.y / (float) blockSize.y));

		findMissingPoints_device << < gridSize, blockSize >> > (fwdProjMissingPoints, noTotalPoints_device, minmaximg,
			forwardProjection, currentDepth, imgSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(
		cudaMemcpy(&renderState->noFwdProjMissingPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));

	{ // render missing points
		blockSize = dim3(256);
		gridSize = dim3((int) ceil((float) renderState->noFwdProjMissingPoints / blockSize.x));

		genericRaycastMissingPoints_device<ITMVoxel, ITMVoxelIndex> << < gridSize, blockSize >> > (
			forwardProjection,
				nullptr,
				nullptr,
				voxelData,
				voxelIndex,
				imgSize,
				invM,
				invertProjectionParams(projParams),
				fwdProjMissingPoints, renderState->noFwdProjMissingPoints,
				*(scene->sceneParams), minmaximg,
				this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL
		);
		ORcudaKernelCheck;
	}
}

void ITMVisualisationEngine_CUDA::CreatePointCloud(const Scene* scene,
                                                   const ITMView* view,
                                                   ITMTrackingState* trackingState,
                                                   ITMRenderState* renderState,
                                                   bool skipPoints) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM() * view->calib.trafo_rgb_to_depth.calib;

	bool useDirectial = this->settings->fusionParams.tsdfMode == TSDFMode::TSDFMODE_DIRECTIONAL;

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_rgb.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	ORcudaSafeCall(cudaMemsetAsync(noTotalPoints_device, 0, sizeof(uint)));

	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;
	Vector4f* locations = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* colours = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	Vector6f* directionalContribution = renderState->raycastDirectionalContribution->GetData(MEMORYDEVICE_CUDA);

	dim3 cudaBlockSize(16, 16);
	dim3 gridSize = getGridSize(imgSize, cudaBlockSize);
	renderPointCloud_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> >
	                                                                (locations, colours, noTotalPoints_device, pointsRay,
		                                                                useDirectial ? directionalContribution : nullptr,
		                                                                scene->localVBA.GetVoxelBlocks(), scene->index.getIndexData(), skipPoints, scene->sceneParams->voxelSize, imgSize, lightSource);
	ORcudaKernelCheck;

	ORcudaSafeCall(
		cudaMemcpy(&trackingState->pointCloud->noTotalPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));
}

void ITMVisualisationEngine_CUDA::FindSurface(const Scene* scene,
                                              const ORUtils::SE3Pose* pose,
                                              const ITMIntrinsics* intrinsics,
                                              const ITMRenderState* renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->noDims, pose->GetInvM(), intrinsics->projectionParamsSimple.all,
	               renderState, false);
}

void ITMVisualisationEngine_CUDA::CreateICPMaps(const Scene* scene,
                                                const ITMView* view,
                                                ITMTrackingState* trackingState,
                                                ITMRenderState* renderState) const
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM();

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_d.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	Vector4f* pointsMap = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* normalsMap = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	Vector4f* normalsRay = renderState->raycastNormals->GetData(MEMORYDEVICE_CUDA);
	Vector3f lightSource = Vector3f(invM.getColumn(3)) / scene->sceneParams->voxelSize;

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));

	if (view->calib.intrinsics_d.FocalLengthSignsDiffer())
	{
		renderICP_device<true> << < gridSize, cudaBlockSize >> > (pointsMap, normalsMap, pointsRay, normalsRay,
			scene->sceneParams->voxelSize, imgSize, lightSource);
	} else
	{
		renderICP_device<false> << < gridSize, cudaBlockSize >> > (pointsMap, normalsMap, pointsRay, normalsRay,
			scene->sceneParams->voxelSize, imgSize, lightSource);
	}
	ORcudaKernelCheck;
}

void ITMVisualisationEngine_CUDA::RenderTrackingError(ITMUChar4Image* outRendering,
                                                      const ITMTrackingState* trackingState,
                                                      const ITMView* view) const
{
	Vector4u* data = outRendering->GetData(MEMORYDEVICE_CUDA);
	const Vector4f* pointsRay = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	const Vector4f* normalsRay = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	const float* depthImage = view->depth->GetData(MEMORYDEVICE_CUDA);
	const Matrix4f& depthImageInvPose = trackingState->pose_d->GetInvM();
	const Matrix4f& sceneRenderingPose = trackingState->pose_pointCloud->GetM();
	Vector2i imgSize = view->calib.intrinsics_d.imgSize;
	const float maxError = this->settings->sceneParams.mu;

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) imgSize.x / (float) cudaBlockSize.x),
	              (int) ceil((float) imgSize.y / (float) cudaBlockSize.y));
	renderPixelError_device<ITMVoxel, ITMVoxelIndex> << < gridSize, cudaBlockSize >> > (
		data, pointsRay, normalsRay, depthImage, depthImageInvPose, sceneRenderingPose,
			view->calib.intrinsics_d.projectionParamsSimple.all, imgSize, maxError);
}

} // namespace ITMLib
